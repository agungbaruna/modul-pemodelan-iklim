[
  {
    "objectID": "praktikum-1.html#pendahuluan",
    "href": "praktikum-1.html#pendahuluan",
    "title": "2  Dynamical Downscaling: Model Weather Research Forecasting (WRF)",
    "section": "2.1 Pendahuluan",
    "text": "2.1 Pendahuluan\nGlobal Climate Model (GCM) adalah alat yang digunakan dalam mensimulasikan keadaan iklim pada masa lalu, masa sekarang, maupun masa depan. GCM memiliki kemampuan dalam melakukan simulasi variabilitas iklim, sifat-sifat fisis, serta kimia di bumi dengan perhitungan secara matematis yang menggambarkan proses interaksi dan timbal balik pada komponen atmosfer, lautan, dan biotik. Kelemahan dalam GCM adalah ketidakmampuan menangkap kejadian-kejadian iklim pada skala regional maupun lokal karena memiliki resolusi spasial yang kecil, yaitu sekitar &gt;100 km. Ketidakmampuan GCM dalam menjelaskan keadaan iklim secara regional maupun lokal disebabkan oleh keterbatasan sumber daya komputasi. Seiring dengan berkembangnya teknologi komputasi, beberapa instansi seperti Met Office Hadley Center, National Center for Atmospheric Research (NCAR), dan European Centre for Medium-Range Weather Forecasts (ECMWF) telah mengembangkan GCM yang mampu menjelaskan fenomena-fenomena cuaca pada skala regional dengan sumber daya komputer yang sangat tinggi. Teknologi komputasi saat ini sangat memudahkan bagi para pengembang GCM, terutama dalam kecepatan eksekusi algoritme prakiraan cuaca numerik. Contohnya, model prakiraan cuaca dari ECMWF, yaitu Integrated Forecasts System (IFS) memiliki resolusi spasial sekitar 9 km. Apakah dengan berkembangnya GCM yang sudah bisa menjelaskan fenomena regional telah menggantikan Regional Climate Model (RCM)? Tentu saja tidak. Peran RCM masih penting dalam proses downscaling resolusi spasial maupun temporal sampai pada skala lokal maupun mikro (mis. turbulensi).\nMetode downscaling merupakan suatu cara dalam mendapatkan informasi spesifik pada suatu wilayah tertentu dengan resolusi tinggi, baik spasial maupun temporal. Metode downscaling di dalam ilmu iklim umum digunakan pada aplikasi dalam bidang hidrologi (Piani, Weedon, et al. 2010), pertanian (Glotter et al. 2014), dan iklim perkotaan (Smid and Costa 2018). Misalnya dalam bidang hidrologi, teknik downscaling digunakan untuk pemodelan debit sungai dan banjir (Piani, Haerter, et al. 2010). Wilby dan Wigley (Wilby and Wigley 1997) mengelompokkan teknik downscaling menjadi 4 kategori, yaitu\n\nRegresi\nMetode regresi merupakan metode downscaling paling awal yang telah digunakan pada kajian perubahan iklim. Hal ini dapat dibuktikan dari penelitian oleh Kim pada tahun 1984 (Kim et al. 1984). Pendekatan ini secara umum membangun hubungan linier atau non-linier antara parameter titik lokasi dengan prediktor variabel dari resolusi kasar. Contoh dari metode ini adalah regresi linier sederhana, regresi linier berganda, Artificial Neural Network (ANN), regresi komponen utama (Principle Component Regression/PCR), dan lain sebagainya. Sudah banyak penelitian yang menerapkan metode ini untuk kajian perubahan iklim (Huth and Kyselỳ 2000; Goly et al. 2014; Sachindra et al. 2014; Pahlavan et al. 2018).\nPola cuaca\nMetode ini dibangun dari hubungan statistik dari variabel cuaca di stasiun observasi atau rata-rata area dengan klasifikasi cuaca tertentu yang dapat diturunkan secara obyektif maupun subyektif. Metode ini secara obyektif dapat meliputi komponen utama, Canonical Correlation Analyses (CCA), aturan Fuzzy, dan Neural Networks. Contoh prosedur pengelompokkan pola cuaca, yaitu European Grosswetterlagen dan British Isles Lamb Weather Types.\nStokastik\nModel WGEN (Richardson 1981) merupakan contoh dari pendekatan ini. Model ini memiliki kemampuan dalam membangkitkan data curah hujan harian berdasarkan peluang kejadian hujan (hujan dan tidak hujan) dengan rantai Markov order satu. Model ini telah digunakan dalam kajian perubahan iklim dan analisis dampak. Model stokastik yang telah diperoleh dari data observasi deret waktu dapat divalidasi dengan GCM dan perlu dikalibrasi terlebih dahulu.\nLimited-area climate models (LAM)\nMetode terakhir untuk melakukan downscaling terhadap GCM adalah dengan menyematkan model iklim dengan area terbatas. Sebenarnya, LAM pada saat ini dapat diistilahkan sebagai Regional Climate Model (RCM). RCM memiliki resolusi spasial kurang dari 100 km. RCM memerlukan sumber daya komputer yang hampir sama dengan menjalankan GCM. RCM memiliki kemampuan dalam mensimulasikan proses-proses atmosfer pada skala menengah, seperti curah hujan orografis dan konveksi awan atau skala tinggi, seperti turbulensi. Contoh dari RCM adalah Weather Research Forecasting (WRF) (Skamarock et al. 2019).\n\nAda dua cara dalam melakukan metode downscaling, yaitu statistik dan dinamik.\nTeknik dynamical downscaling dapat menjalankan simulasi berbagai proses fisika (termodinamika, kekekalan energi, dan gerak) untuk setiap skala piksel. Teknik ini membutuhkan kondisi batas menggunakan data GCM dan perlu menentukan pemilihan lokasi spesifik. Teknik ini merujuk pada penggunaan RCM untuk meningkatkan skala spasial dan temporal. Model iklim regional meliputi komponen dinamik, fisik, maupun kimia. Komponen dinamik atmosfer memperhitungkan komponen fisika atmosfer yang mencakup proses-proses fisik, seperti radiasi gelombang panjang dan pendek, presipitasi, dan proses pertukaran energi di permukaan bumi atau laut. Proses pada skala sub-piksel dimodelkan oleh berbagai skema parameterisasi yang tentunya dapat berasal dari perhitungan matematika (integral atau diferensial) serta statistik. Model dynamical downscaling telah tersedia banyak saat ini, seperti Weather Research Forecasting (WRF), ICTP Regional Climate Model (RegCM), Hadley Centre Regional Climate Model (HadRM), The Regional Climate Model (REMO), dan The Model for Prediction Across Scale (MPAS). Model WRF akan dijelaskan pada modul ini, mulai dari instalasi hingga menampilkan hasil.\nWRF merupakan salah satu model dynamical downscaling yang saat ini semakin berkembang dengan tujuan riset dan operasional. WRF memiliki spesifikasi dalam berbagai aplikasi prediksi di dalam sistem bumi, seperti kimia atmosfer, hidrologi, kebakaran hutan, siklon, dan iklim regional. Selain simulasi dalam skala regional, WRF telah mampu menjalankan simulasi fenomena cuaca mikro cukup akurat, seperti turbulensi (Talbot et al. 2012) (Xu et al. 2018) (Bao et al. 2018). Sebanyak lebih dari 36.000 pengguna WRF tersebar di 162 negara, termasuk Indonesia yang telah menggunakan WRF untuk kebutuhan operasional (Powers et al. 2017). Ada dua jenis model WRF berdasarkan penyelesaian persamaan aliran fluida atmosfer, yaitu Advanced Research WRF (ARW) dan Nonhydrostatic Mesoscale Model (NMM). WRF-ARW dikembangkan oleh National Centre of Atmosphere Research (NCAR), sedangkan WRF-NMM dikembangkan oleh National Centre of Environmental Prediction (NCEP) (Skamarock et al. 2019). Secara umum, WRF mampu melakukan simulasi beberapa komponen Numerical Weather Prediction (NWP) Gambar 2.1. Berdasarkan aplikasi tertentu, WRF memiliki beberapa turunan model, seperti WRF-Chem (kimia atmosfer), WRF-Hydro (hidrologi), dan WRF-Fire (kebakaran hutan dan lahan).\n\n\n\nGambar 2.1: Proses secara umum perlu diparameterisasi di dalam model iklim (Sonkaew et al.)\n\n\nWRF diimplementasikan dalam bahasa pemrograman komputer. Jika Anda melihat repositori github WRF, jenis bahasa pemrograman yang paling banyak digunakan adalah Fortran yang berisikan algoritme berbagai perhitungan fisika dan kimia. Model WRF dapat dijalankan pada personal komputer hingga super komputer. Sebenarnya, Anda dapat menjalankan WRF dengan hanya 1 prosesor, tetapi mungkin membutuhkan waktu lama akibat dari resolusi spasial dan temporal yang tinggi, serta cakupan pemilihan wilayah yang cukup luas. Proses perhitungan model dinamik maupun fisik akan lebih cepat apabila memakai banyak prosesor atau yang bisa disebut dengan komputasi paralel. Kerangka kerja perangkat lunak WRF mendukung komputasi paralel yang efisien pada berbagai platform komputasi. Model atmosfer membawa kumpulan komputasi yang sama di setiap piksel vertikal maupun horizontal Gambar 2.2. Kita mungkin telah mengenal jenis prosesor yang tersedia saat ini, seperti Intel dan AMD. Jenis prosesor yang dibuat dapat mempengaruhi kecepatan proses perhitungan. Untuk perhitungan paralel, Anda dapat menggunakan tipe prosesor desktop, mobile (prosesor di laptop), maupun server, tetapi juga perlu memperhatikan banyaknya core maupun frekuensi yang tertera pada setiap tipe prosesor.\n\n\n\nGambar 2.2: Ilustrasi Model Iklim\n\n\nTerkait dengan bahasa pemrograman yang digunakan di dalam WRF, yaitu bahasa Fortran dan C, kode skrip terlebih dahulu harus dikompilasi dengan program Compiler. Compiler ini bertujuan mengubah bahasa dari kode yang diketik menjadi bahasa mesin. Ada berbagai macam program Compiler yang tersedia secara gratis, salah satunya adalah GNU Compiler Collection (gcc). Selain GNU, perusahaan seperti Intel, AMD, maupun NVIDIA juga memiliki program Compiler yang dapat digunakan secara gratis serta mendukung komputasi paralel. Di dalam modul praktikum ini, Anda dapat memilih salah satu dari dua Compiler yang akan dijelaskan, yaitu GNU atau Intel. Kami mencoba melakukan simulasi WRF dengan 10 kali ulangan pada dua tipe Compiler dan Prosesor. Perbedaan penggunaan tipe Compiler serta Prosesor dapat mempengaruhi waktu simulasi Gambar 2.3.\n\n\n\nGambar 2.3: Perbedaan waktu simulasi WRF pada tipe Compiler, Distro, dan Prosesor yang digunakan"
  },
  {
    "objectID": "praktikum-1.html#pemrograman-bash",
    "href": "praktikum-1.html#pemrograman-bash",
    "title": "2  Dynamical Downscaling: Model Weather Research Forecasting (WRF)",
    "section": "2.2 Pemrograman Bash",
    "text": "2.2 Pemrograman Bash\nSebagai salah satu tool scripting yang umum digunakan pada Linux, Bash (Bourne Again Shell) sangat bermanfaat bagi para penggunanya. Sebagian besar dalam menjalankan model iklim, Bash digunakan untuk menjalankan instalasi, simulasi, sampai pada analisis data. Pengguna model iklim disarankan mempelajari dasar-dasar pemrograman ini agar memahami berbagai perintah dari cara kerja instalasi dan simulasi dari model iklim tertentu. Para pengembang model iklim biasanya menyediakan dokumen User Guide. File ini berisi mengenai cara instalasi, simulasi, informasi file, dan berbagai aplikasi tambahan dalam mengoperasikan/menjalankan model iklim tersebut. Bagi para pengguna Windows atau MacOS, perhatikan subbab di bawah ini.\n\n2.2.1 Pemrograman Bash pada Sistem Operasi Windows\nBagi Anda yang memiliki sistem operasi Windows, Anda diharuskan memasang Windows Subsystem Linux (WSL) untuk dapat menjalankan Bash. Untuk menjalankan WRF, Anda memerlukan sistem operasi berbasis Linux dengan distribusi yang tersedia saat ini. Pada modul ini, distro Ubuntu dipilih untuk simulasi WRF. WSL dapat digunakan bagi pengguna Windows 10/11. WSL dapat dijalankan pada Windows 10/11 dan Windows Server 2019 dengan versi minimum 1803. Saat ini, WSL versi 2 (WSL-2) telah tersedia yang dapat berjalan pada Windows 10 versi 1903 ke atas. Kami merekomendasikan Anda untuk memasang WSL-2 daripada WSL-1 karena prosesnya lebih cepat. Untuk mengaktifkan WSL, Anda dapat mengikuti beberapa langkah berikut ini.\n\nUnduh WSL-2 pada halaman ini dan Install.\nBuka menu Control Panel dan cari Program and Features\nKlik Turn Windows Features On or Off\nScroll ke paling bawah. Kemudian, aktifkan tanda centang pada Windows Subsystem for Linux dan Virtual Machine Platform\nTunggu proses update sampai selesai, kemudian klik Restart Now (pastikan simpan data-data pekerjaan dan tutup semua aplikasi)\nSetelah proses restart selesai, cari aplikasi dan unduh Ubuntu pada Microsoft Store\nBuka aplikasi Ubuntu yang telah terunduh dan tunggu konfigurasi selesai\nMasukkan Username dan Password (Catatan: kami sarankan sama dengan user dan pass Windows 10/11, tetapi boleh beda. Hasil ketikan password tidak muncul di terminal)\nKetikkan pada terminal bash     sudo apt update\nAnda juga dapat membuka terminal Ubuntu pada terminal Windows PowerShell atau Command Prompt dengan mengetik wsl atau wsl.exe\n\nSelain WSL, Anda juga dapat menggunakan Cygwin atau MinGW, hanya saja Anda perlu memilih beberapa paket yang akan digunakan. Tentu cara ini sangat rumit dan membutuhkan waktu cukup lama saat instalasi.\n\n\n2.2.2 Instalasi Docker pada MacOS (chipset M1 dan M2)\nUntuk MacOS, aplikasi terminal-nya sudah mendukung Bash, hanya saja WRF tidak bisa dipasang, khususnya pada arsitektur ARM64 (MacBook M1 atau M2). Kami sudah mengikuti langkah-langkah pada website WRF-Forum ini, tetapi masih terdapat kendala. Oleh karena itu, kami menggunakan aplikasi Docker sebagai solusi.\n\nUnduh dan pasang Docker untuk MacOS berdasarkan prosesor pada link di bawah ini.\n\nMacOS Intel\nMacOS M1 atau M2\n\nBuka aplikasi Docker melalui menu atau melalui terminal dengan perintah berikut ini.\nopen -a Docker\nJendela Docker Desktop akan muncul.\nKemudian, tutup aplikasi Docker Desktop. Perintah ini tidak memberhentikan proses Docker, hanya menutup mode GUI-nya saja. Aplikasi Docker masih terus berjalan apabila ada icon Docker pada notifikasi.\n\n\n\n\nIcon Docker\n\n\n\nBukalah terminal\nKetikkan perintah berikut untuk mengunduh image Ubuntu versi 20.04\ndocker pull ubuntu:20.04\nUntuk menjalankan image, ketikkan perintah berikut.\ndocker run -it --name wrf-ubuntu ubuntu:20.04\nPerintah ini menjalankan image Ubuntu versi 20.04 dan masuk ke container dengan nama wrf-ubuntu. Anda dapat mengetikkan perintah-perintah Bash di dalam container ini.\nTerdapat beberapa perintah yang belum tersedia seperti pada Ubuntu versi Desktop maupun WSL. Misalnya perintah nano, wget, bash-completion, dan git. Untuk mengunduhnya, ketikkan perintah berikut.\napt update\napt -y install nano wget git bash-completion\n\n\n\n\n\n\nCatatan\n\n\n\nUntuk selanjutnya, Anda tidak perlu mengetik perintah sudo (seperti pada WSL) di dalam terminal Docker karena Anda sudah masuk sebagai root.\n\n\nUntuk keluar dari container Ubuntu, ketikkan perintah exit atau dengan shortcut Ctrl + D.\nJika Anda ingin menjalankan container Ubuntu yang sudah dibuat sebelumnya, ketikkan perintah berikut.\ndocker start -i wrf-ubuntu\n\nPenggunaan Docker pada MacOS HANYA untuk menjalankan WRF saja. Selebihnya pada tahapan analisis/visualisasi data, Anda dapat menggunakan software lain yang masih mendukung MacOS.\n\n\n2.2.3 Dasar-dasar Pemrograman Bash\nBash merupakan terminal shell umum pada Linux. Anda bisa menjalankan shell lain, seperti ksh (Korn Shell), zsh, dan csh (C shell). Untuk menjalankan Bash, Anda bisa menekan Ctrl+Alt+T atau carilah aplikasi Terminal. Khusus Windows 10, Anda dapat mencari aplikasi “Ubuntu” atau “wsl.exe”. Tampilan Bash seperti pada Gambar 2.4. Tulisan menunjukkan nama user dan tanda berarti menunjukkan lokasi folder saat ini.\n\n\n\nGambar 2.4: Bash pada Ubuntu\n\n\nJika Anda mengetik perintah pwd pada Bash, hasilnya adalah seperti di bawah ini atau bisa dilihat pada Gambar 2.5.\n\n\n\nGambar 2.5: Perintah pwd pada terminal Bash\n\n\nPerintah dasar lainnya yang sering digunakan oleh pengguna Linux adalah ls atau ll (Gambar 2.6). Perintah ini berfungsi untuk melihat nama folder dan file yang berada di direktori pada lokasi saat ini. Untuk berpindah lokasi folder, Anda dapat mengetik perintah cd dan pilih folder yang ingin dibuka, contohnya cd Documents/ atau cd Documents (Gambar 2.7). Anda dapat kembali ke folder sebelumnya dengan mengetik perintah cd ..\n\n\n\nGambar 2.6: Perintah ls pada terminal Bash\n\n\n\n\n\nGambar 2.7: Perintah cd pada terminal Bash\n\n\nAnda dapat membuat folder baru dengan perintah mkdir, memindahkan folder atau file dengan mv, menghapus file dengan rm, menghapus folder dengan rmdir, membuat file baru dengan touch, dan menyalin folder atau file dengan cp. Contoh penggunaan beberapa perintah tersebut dapat dilihat sebagai berikut.\n\nMisalkan kita ingin membuat folder Tes-folder\nmkdir Tes-folder\nAnda juga dapat membuat lebih dari 1 folder, misalnya Tes-folder-1 dan Tes-folder-2\nmkdir Tes-folder-1 Tes-folder-2\nUntuk memastikan ketiga folder tersebut telah dibuat, ketik perintah ls\nls\nMisalkan kita ingin membuat file tes-file di dalam folder Tes-folder. Perintah touch bertujuan membuat file kosong.\ncd Tes-folder\ntouch tes-file\nls\nKemudian, file tes-file kita pindahkan ke direktori sebelumnya dan diganti namanya dengan tes-file-pindah\nmv tes-file ../tes-file-pindah\nKembali ke folder sebelumnya\ncd ..\nKetik perintah ls untuk memastikan file tes-file telah dipindahkan ke direktori sebelumnya dengan berubah nama menjadi tes-file-pindah\nls \nFile tes-file-pindah dihapus menggunakan perintah rm\nrm tes-file-pindah\nls\nUntuk menghapus folder, misalkan Tes-folder-1, Anda dapat menggunakan perintah rm dengan ditambahkan parameter -rf.\nrm -rf Tes-folder-1\n\n\n\n\n\n\n\nPerhatian\n\n\n\nHati-hati dalam menggunakan parameter -rf karena folder yang telah dihapus beserta file-file di dalamnya tidak berada di dalam Recycle Bin"
  },
  {
    "objectID": "praktikum-1.html#instalasi-software-pengolahan-data-dan-model-wrf",
    "href": "praktikum-1.html#instalasi-software-pengolahan-data-dan-model-wrf",
    "title": "2  Dynamical Downscaling: Model Weather Research Forecasting (WRF)",
    "section": "2.3 Instalasi Software Pengolahan Data dan Model WRF",
    "text": "2.3 Instalasi Software Pengolahan Data dan Model WRF\nPada tahapan ini, Kami menjelaskan mengenai tahapan instalasi aplikasi pengolahan data pendukung untuk memproses data luaran WRF serta instalasi model WRF di Ubuntu versi 20.04. Saat kami menguji WRF di Ubuntu, proses instalasi serta simulasi tidak mengalami masalah. Anda dipersilahkan menggunakan distro yang lain, seperti Fedora, CentOS, Almalinux, atau Manjaro, tetapi kami tidak dapat menjamin keberhasilan instalasi dan simulasi pada distro tersebut.\n\n2.3.1 Instalasi Software Pengolahan Data\n\nNCAR Command Language (NCL) dan Python\nNCL merupakan bahasa pemrograman interpreter yang dikembangkan oleh National Centre of Atmospheric Research (NCAR) dan memiliki kegunaan dalam proses analisis dan visualisasi data-data cuaca dan iklim. Aplikasi NCL dibutuhkan untuk memvisualisasikan lokasi kajian sebelum disimulasikan. Pengembang WRF telah menyediakan skrip NCL untuk memudahkan dalam ketepatan pemilihan lokasi sesuai dengan keinginan pengguna. Python merupakan bahasa pemrograman general yang memiliki banyak kegunaan, khususnya dalam analisis dan visualisasi data-data dengan tambahan modul (packages). Dalam menuliskan kode Python, Anda dapat menggunakan teks editor yang umum digunakan seperti Jupyter Notebook. Untuk modul yang akan dipakai dalam praktikum ini adalah wrf-python. Langkah-langkah pemasangan NCL dan Python sebagai berikut.\n\nUntuk memasang NCL, Anda harus mengunduh aplikasi Miniconda untuk Linux pada website https://repo.anaconda.com/miniconda/Miniconda3-py39_22.11.1-1-Linux-x86_64.sh dengan perintah pada terminal Bash sebagai berikut.\nwget https://repo.anaconda.com/miniconda/Miniconda3-py39_22.11.1-1-Linux-x86_64.sh\nAnda tidak dapat menggunakan NCL pada sistem operasi Windows, kecuali Anda memiliki Windows Subsystem Linux (WSL).\nKemudian, lakukan pemasangan Miniconda dengan perintah di bawah ini.\nbash Miniconda3-py39_22.11.1-1-Linux-x86_64.sh\nSelanjutnya tekan ENTER. Terminal akan menampilkan End-User License Agreement (EULA), tekan ENTER atau SPACE sampai muncul perintah seperti di bawah ini.\nDo you accept the license terms? [yes|no]\n[no] &gt;&gt;&gt;\nKemudian, ketikkan yes untuk melanjutkan proses instalasi dan tekan ENTER. Secara otomatis, Python sebenarnya telah terpasang di dalam Miniconda.\n\nTutup terminal Anda dan buka kembali. Perhatikan pada tulisan (base) di paling kiri nama user. Jika tulisan tersebut sudah muncul, proses pemasangan Miniconda telah berhasil.\nSelanjutnya, lakukan pemasangan package mamba dengan perintah.\nconda install mamba -n base -c conda-forge\n\n\n\n\n\n\n\nCatatan\n\n\n\nPackage mamba memungkinkan dapat mempercepat pengunduhan dan pemasangan package-package di dalam Miniconda.\n\n\n\nLakukan proses pembuatan environment dengan nama ncl dan pemasangan NCL beserta package lainnya dengan perintah.\nconda create -n ncl\nconda activate ncl\nmamba install -c conda-forge jupyter notebook xarray netcdf4 scipy pyngl pynio matplotlib cartopy wrf-python ncl \n\n\n\n\n\n\n\nPerhatian\n\n\n\nSaat modul ini dibuat, paket wrf-python belum mendukung arsitektur MacOS M1/M2, baik di terminal MacOS maupun terminal Linux melalui Docker, kecuali MacOS Intel. Kami sarankan Anda dapat menggunakan aplikasi lainnya seperti RStudio, Julia, atau Python untuk pengolahan data luaran WRF.\n\n\n\nSaat Anda ingin memulai menggunakan program NCL, aktifkan terlebih dahulu environment ncl dengan perintah di bawah ini. Kemudian, tulisan (base) menjadi (ncl) yang menandakan bahwa environment telah berhasil diaktifkan.\nconda activate ncl\nUntuk membuka Jupyter Notebook, gunakan perintah ini. Aplikasi akan muncul pada browser bawaan Anda (Google Chrome, Microsoft Edge, atau Safari).\njupyter notebook\nUntuk menutup Jupyter Notebook, Anda dapat menekan tombol CTRL+C pada terminal.\nUntuk keluar dari environment ncl, ketikkan perintah conda deactivate.\n\n\n\n\n\n\n\nCatatan\n\n\n\nEnvironment ncl akan terus dipakai, mulai dari pemasangan WRF hingga analisis dan visualisasi luaran WRF. NCAR telah mengembangkan wrf-python secara khusus untuk analisis dan visualisasi luaran WRF.\n\n\n\n\nR dan RStudio\nSama seperti Python dan NCL, R merupakan bahasa pemrograman interpreter, namun dibuat secara khusus untuk analisis dan visualisasi data-data statistik. Beberapa package R telah dikembangkan untuk memudahkan proses analisis data-data cuaca dan iklim, seperti ncdf4, raster, dan metR. RStudio umum digunakan dalam mengetik bahasa pemrograman R secara interaktif. Untuk menuliskan skrip R, dibutuhkan aplikasi teks editor, salah satunya adalah RStudio. RStudio mendukung bukan hanya menuliskan skrip R, melainkan bahasa pemrograman lainnya, seperti Markdown, C++, Javascript, dan Python. Sebenarnya, Anda dapat menuliskan skrip Python pada RStudio dengan bantuan package reticulate. Hanya saja di dalam modul ini, Kami menggunakan Jupyter Notebook untuk menuliskan skrip Python.\nUntuk mengunduh R dan RStudio Desktop, Anda dapat menggunakan halaman website di bawah ini sesuai dengan sistem operasi yang Anda gunakan. Bagi pengguna Windows, Anda diharuskan mengunduh aplikasi Rtools karena beberapa paket tertentu membutuhkan kompilasi dengan Compiler GNU pada saat proses instalasi, seperti raster, tidyverse, dan ncdf4.\n\nR\n\nWindows 10/11: https://cran.r-project.org/bin/windows/base/R-4.2.2-win.exe\nMacOS (Intel): https://cran.r-project.org/bin/macosx/base/R-4.2.2.pkg\nMacOS (ARM, M1/M2): https://cran.r-project.org/bin/macosx/big-sur-arm64/base/R-4.2.2-arm64.pkg\nUbuntu: ikuti perintah dan langkah-langkah di https://cran.r-project.org/bin/linux/ubuntu\n\nRStudio\n\nWindows 10/11: https://download1.rstudio.org/electron/windows/RStudio-2022.12.0-353.exe\nMacOS (Intel/ARM): https://download1.rstudio.org/electron/macos/RStudio-2022.12.0-353.dmg\nUbuntu 22.04 LTS: https://download1.rstudio.org/electron/jammy/amd64/rstudio-2022.12.0-353-amd64.deb\n\n\n\n\nJulia\nBahasa pemrograman ini relatif baru dibandingkan dengan Python dan R. Sama seperti keduanya, Julia merupakan bahasa pemrograman interpreter dan tersedia gratis. Pengembang Julia mengatakan bahwa bahasa ini memiliki kecepatan eksekusi secepat bahasa C/C++. Artinya, kecepatan eksekusi Julia berpotensi lebih cepat daripada Python maupun R. Anda dapat mengunduh Julia di julialang.org sesuai dengan sistem operasi yang Anda miliki. Untuk membaca data netcdf dari WRF, Anda dapat menggunakan package NetCDF.jl. Anda perlu memasang package tersebut pada terminal interaktif Julia. Untuk menuliskan skrip Julia, Anda dapat memanfaatkan Jupyter Notebook dan tentunya memerlukan package IJulia.jl. Berikut ini adalah langkah-langkahnya.\n\nBuka terminal interaktif Julia (julia) dan ketikkan perintah berikut untuk memasang package NetCDF.jl dan IJulia.jl.\nusing Pkg\nPkg.add(\"NetCDF\")\nPkg.add(\"IJulia\")\nSetelah berhasil memasang package, Anda dapat menuliskan skrip Julia pada Jupyter Notebook. Untuk membuka Jupyter Notebook, ketikkan perintah berikut pada terminal interaktif Julia.\nusing IJulia\nnotebook()\nSkrip tersebut akan mengeksekusi instalasi miniconda di dalam Julia dengan disertai Jupyter Notebook. Jika instalasi berhasil, Jupyter Notebook akan terbuka di browser Anda (Google Chrome, Microsoft Edge, atau Safari). Untuk menutup Jupyter Notebook, Anda dapat menekan tombol CTRL+C pada terminal interaktif Julia.\n\n\n\n\n2.3.2 Sebelum Mulai\nAnda perlu mencoba dasar pemrograman Bash sebelum memulai mengunduh data, memasang beberapa package, sampai menjalankan simulasi WRF. Silahkan Anda ikuti langkah-langkah di bawah ini agar memudahkan dalam mencoba praktikum ini.\n\nBuka terminal Bash\n\nUntuk Windows 10/11, buka aplikasi Windows Power Shell. Kemudian, ketikkan perintah seperti di bawah ini. Setelahnya, akan muncul terminal Bash.\nwsl\nUntuk Ubuntu atau disto Linux lainnya, carilah program Terminal atau bisa menggunakan shortcut Ctrl+Alt+T\nUntuk MacOS M1/M2 menggunakan Docker, jalankan image Ubuntu versi 20.04 pada terminal dengan perintah di bawah ini.\ndocker run -it --name wrf-ubuntu ubuntu:20.04\n\nSaat Anda membuka terminal, pastikan lokasi folder/direktori saat ini adalah /home/&lt;user_name&gt;, di mana user_name adalah nama user pada laptop/komputer Anda masing-masing. Perhatikan kembali Gambar 2.5 bahwa untuk melihat lokasi direktori Anda sekarang bisa mengetik perintah pwd pada terminal atau dengan melihat simbol ~ yang terletak di sebelah kiri $. Untuk Docker, lokasi direktori saat ini adalah /. Lokasi $HOME berada di folder /root.\ncd $HOME\nBuat folder kerja dengan nama WRF-Model untuk menampung data-data, package, serta source code WRF. Perintah pada terminal Bash adalah sebagai berikut.\nmkdir WRF-Model\nKemudian, bukalah folder WRF-Model (atau dengan nama lainnya) dengan perintah\ncd WRF-Model\nSekarang, Anda berada di folder WRF-Model (Perhatikan ~ berubah menjadi ~/WRF-Model)\nDi dalam WRF-Model, buatlah folder data guna untuk meletakkan data masukan WRF (data statik dan data cuaca).\nUnduh source code WPS (WRF Pre-Processing) dan WRF pada halaman Github NCAR. Source code WRF berisikan algoritma perhitungan fisik dan dinamik atmosfer, sedangkan WPS berisikan algoritma persiapan data masukan atmosfer dari GCM dan pemilihan lokasi dan waktu. Gunakan perintah di bawah ini.\n# 1. Unduh WPS\ngit clone https://www.github.com/wrf-model/WPS\n# 2. Unduh WRF\ngit clone https://www.github.com/wrf-model/WRF\n\nLangkah-langkah di atas masih berlanjut pada subbab selanjutnya.\n\n\n2.3.3 Data dan Software Pendukung\n\nSoftware Pendukung\nUntuk memasang WRF, Anda perlu menyiapkan perangkat lunak pendukung serta data contoh untuk mensimulasikan WRF. Perangkat lunak tersebut dapat diunduh melalui halaman Github ini. Untuk mengunduh source code, pilih &lt;&gt; Code \\(\\rightarrow\\) Download ZIP (Gambar 2.8). Anda dapat mengunduh secara manual atau menggunakan perintah git clone pada terminal.\nsudo apt -y install git #Install program git jika belum ada\ngit clone https://www.github.com/agungbaruna/pyWRF-install\n\n\n\nGambar 2.8: Unduh source code\n\n\n\n\nData\nData-data masukan untuk WRF telah tersedia dan unduh pada halaman web https://s.id/wrf-data. Kami menyarankan untuk menggunakan Wi-Fi karena ukuran data cukup besar. Data yang telah diunduh Anda pindahkan ke folder data yang berada di dalam WRF-Model.\n\n\n1. Global Forecast System (GFS)\nUntuk data masukan yang digunakan berasal dari NOAA yang bernama Global Forecasts System (GFS). GFS memiliki resolusi spasial \\(0.25^o\\) (~25 km), \\(0.50^o\\) (~50 km), dan \\(1.00^o\\) (~ 100 km). GFS memiliki produk data prakiraan maupun analisis/historis cuaca secara global dengan resolusi temporal per 1 dan 3 jam. Anda dapat mengunduh data ini pada salah satu halaman web berikut.\n\nAWS S3: https://noaa-gfs-bdp-pds.s3.amazonaws.com\nResarch Data Archive (RDA) NCAR: https://rda.ucar.edu/datasets/ds084.1\nNCEP Central Operations: https://nomads.ncep.noaa.gov/\n\nData GFS yang digunakan dalam praktikum ini memiliki waktu 1-3 Januari 2022 pada pukul 00:00, 06:00, 12:00, dan 18:00 UTC dengan resolusi spasial \\(1.00^o\\) yang telah diunduh pada halaman web AWS S3 Bucket.\n\n\n2. ERA5\nSelain GFS, Anda dapat menggunakan data masukan dari institusi lain, seperti ECMWF pada produk ERA5. ERA5 merupakan data reanalisis sehingga hanya memiliki produk historis. Anda dapat mengunduhnya melalui Climate Data Store (CDS) pada halaman https://cds.climate.copernicus.eu. ERA5 memiliki resolusi spasial sebesar \\(0.25^o\\) dengan temporal per 1 jam. Data ERA5 memiliki dua tipe, yaitu data permukaan tanah (Single Levels) dan atmosfer untuk setiap ketinggian (Pressure Levels). Anda diharuskan mengunduh dua tipe data ini dengan variabel yang dipilih adalah sebagai berikut.\n\nERA5 hourly data on Pressure Levels:\n\n\n\ngeopotential\nrelative humidity\nspecific humidity\n\n\ntemperature\nu-component wind\nv-component wind\n\n\n\nERA5 hourly data on Single Levels:\n\n\n\n\n\n\n\n\n10m u-component of wind\n10m v-component of wind\n2m dewpoint temperature\n\n\n2m temperature\nland sea mask\nmean sea level pressure\n\n\nsea ice cover\nsea surface temperature\nskin temperature\n\n\nsnow depth\nsoil temperature level 1\nsoil temperature level 2\n\n\nsoil temperature level 3\nsoil temperature level 4\nsurface pressure\n\n\nvolumetric soil water layer 1\nvolumetric soil water layer 2\nvolumetric soil water layer 3\n\n\nvolumetric soil water layer 4\n\n\n\n\n\n\nAnda tidak diharuskan mengunduh semua waktu karena CDS membatasi banyaknya permintaan data dari pengguna sehingga Anda tidak dapat mengunduh semua data sekaligus. Data ERA5 yang akan digunakan pada praktikum ini memiliki waktu yang sama dengan GFS.\n\n\n3. Data Statik WPS\nData statik ini wajib diunduh untuk menjalankan WRF. Isi data ini seperti tipe permukaan lahan, nilai Leaf Area Index (LAI), tipe tanah, dan elevasi permukaan. Anda dapat mengunduhnya di https://www2.mmm.ucar.edu/wrf/src/wps_files/geog_high_res_mandatory.tar.gz. File tersebut berukuran 2 GB dan setelah diekstrak dapat mencapai 30 GB. Data ini sudah tersedia di dalam link https://s.id/wrf-data. Untuk mengekstraknya, gunakan perintah berikut.\ncd data\ngunzip geog_high_res_mandatory.tar.gz\ntar -xf geog_high_res_mandatory.tar\ncd .. # Kembali ke folder WRF-Model\nSelanjutnya, folder WPS_GEOG akan muncul di dalam folder data/\n\n\n\n2.3.4 Instalasi Software Compiler\nInstalasi ini meliputi cara melakukan kompilasi dengan dua Compiler berbeda, yaitu GNU dan Intel. Anda dipersilahkan memilih salah satu langkah. Proses kompilasi untuk semua package yang telah terunduh tidak dapat dilakukan pada Compiler yang berbeda.\n\n1. GNU\nSebelum Anda memasuki tahapan instalasi package yang terdapat dalam folder pyWRF-install, pasang terlebih dahulu package dependencies dengan perintah di bawah ini.\nsudo apt -y update && sudo apt -y upgrade\nsudo apt -y install gfortran gcc make m4 csh g++\n\n\n2. Intel\nBerbeda dengan GNU, tipe Compiler Intel memang agak rumit untuk memasangnya. Namun, Compiler ini sebenarnya lebih efisien dalam hal kecepatan saat mensimulasikan WRF. Kami sudah membandingkan waktu simulasi dengan Compiler tipe ini lebih cepat dibandingkan dengan GNU Gambar 2.3.\nAnda dapat memperoleh software ini di halaman resmi Intel. Kami sudah menyediakan software tersebut pada tautan s.id/wrf-intel-compiler. Terdapat 2 file instalasi Compiler, yaitu Fortran, C, dan MPI (untuk komputasi paralel). Jumlah ukuran 2 file tersebut cukup besar, sekitar 5 GB. Letakkan 2 file ini di dalam folder WRF-Model. Perhatikan langkah-langkah berikut ini.\n# 0. Package pendukung\nsudo apt -y install make m4 csh\n# 1. oneAPI Base Toolkit\nbash l_BaseKit_p_2023.1.0.46401_offline.sh -a -s --eula accept\n# 2. oneAPI HPC Toolkit\nbash l_HPCKit_p_2023.1.0.46346_offline.sh -a -s --eula accept\nLokasi folder hasil instalasi terdapat di $HOME/intel. Perintah untuk memanggil program Compiler Intel belum menjadi ENVIRONMENT VARIABLE. Untungnya, Intel menyediakan skrip untuk memanggil semua program Compiler secara default, yaitu terdapat di dalam $HOME/intel/oneapi/setvars.sh. Ketika memanggil skrip tersebut, ENVINRONMENT VARIABLE milik Miniconda secara otomatis dinonaktifkan (tulisan &lt;base&gt; hilang). Perintah untuk memanggil skrip setvars.sh adalah sebagai berikut.\nsource $HOME/intel/oneapi/setvars.sh\n\n\n\n2.3.5 Instalasi Package\nInstalasi beberapa package meliputi zlib, libpng, jasper, hdf5, netcdf-c, dan netcdf-fortran. Perlu diperhatikan dan lihat pada terminal bahwa Anda berada di folder ~/WRF-Model. Masukkan beberapa perintah ENVIRONMENT VARIABEL di bawah ini dengan perintah export.\nexport ODIR=$HOME/WRF-Model\nexport PATH=$ODIR/bin:$PATH\nexport LD_LIBRARY_PATH=$ODIR/lib:$LD_LIBRARY_PATH\nexport LDFLAGS=-L$ODIR/lib\nexport CPPFLAGS=-I$ODIR/include\nexport NETCDF=$ODIR\nexport HDF5=$ODIR\nexport JASPERLIB=$ODIR/lib\nexport JASPERINC=$ODIR/include\nLangkah ini wajib dilakukan pada saat melakukan instalasi package, WRF, dan WPS. Pendefinisian ENVIRONMENT VARIABLE ini berlaku untuk GNU maupun Intel.\n\n1. GNU\nBerikut ini langkah-langkah memasang package pada Compiler GNU. Buka terlebih dahulu folder pyWRF-install/libraries dengan mengetik perintah cd pyWRF-install/libraries. Kemudian, ikuti langkah-langkah berikut ini.\n\nzlib\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf zlib-1.2.13.tar.gz\n# 2. Buka folder hasil ekstrak\ncd zlib-1.2.13\n# 3. Konfigurasi \nCC=gcc ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\nlibpng\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf libpng-1.6.37.tar.gz\n# 2. Buka folder hasil ekstrak\ncd libpng-1.6.37\n# 3. Konfigurasi \nCC=gcc ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\njasper\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf jasper-1.900.1.tar.gz  \n# 2. Buka folder hasil ekstrak\ncd jasper-1.900.1\n# 3. Konfigurasi \nCC=gcc ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\nBagi pengguna MacOS M1/M2 dengan terminal Docker, gunakan perintah berikut ini untuk instalasi Jasper.\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf jasper-1.900.1.tar.gz  \n# 2. Buka folder hasil ekstrak\ncd jasper-1.900.1\n# 3. Mengunduh config.guess\nwget -N -O acaux/config.guess \"http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\"\n# 4. Konfigurasi\nCC=gcc ./configure --prefix=$ODIR\n# 5. Instalasi\nmake check install\nopenMPI\nJika Anda berencana menjalankan WRF hanya dengan 1 prosesor, Anda dapat melewati langkah ini. Akan tetapi, kami menyarankan untuk memasang program ini untuk mempersingkat waktu simulasi WRF.\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf openmpi-4.1.4.tar.gz  \n# 2. Buka folder hasil ekstrak\ncd openmpi-4.1.4\n# 3. Konfigurasi \nCC=gcc FC=gfortran ./configure --prefix=$ODIR\n# 4. Instalasi\nmake\nmake install\nhdf5\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf hdf5-1.12.0.tar.gz \n# 2. Buka folder hasil ekstrak\ncd hdf5-1.12.0\n# 3. Konfigurasi \nCC=gcc FC=gfortran ./configure --prefix=$ODIR --with-default-api-version=v18 --enable-fortran\n# 4. Instalasi\nmake\nmake install\nnetcdf-c\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf netcdf-c-4.7.4.tar.gz \n# 2. Buka folder hasil ekstrak\ncd netcdf-c-4.7.4\n# 3. Konfigurasi \nCC=gcc ./configure --prefix=$ODIR --disable-dap\n# 4. Instalasi\nmake\nmake install\nnetcdf-fortran\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf netcdf-fortran-4.5.3.tar.gz \n# 2. Buka folder hasil ekstrak\ncd netcdf-fortran-4.5.3\n# 3. Konfigurasi \nCC=gcc FC=gfortran ./configure --prefix=$ODIR\n# 4. Instalasi\nmake\nmake install\n\n\n\n2. Intel\nBerikut ini langkah-langkah memasang package pada Compiler Intel. Buka terlebih dahulu folder pyWRF-install/libraries dengan mengetik perintah cd pyWRF-install/libraries. Untuk proses instalasi menggunakan Intel, sama saja dengan GNU. Hanya saja, perbedaannya adalah definisi dari variabel CC maupun FC. Untuk Intel, variabel CC=icc dan FC=ifort. Jangan lupa untuk mengaktifkan ENVIRONMENT VARIABLE dari Intel dengan mengetik perintah ini!\nsource ~/intel/oneapi/setvars.sh\n\nzlib\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf zlib-1.2.13.tar.gz\n# 2. Buka folder hasil ekstrak\ncd zlib-1.2.13\n# 3. Konfigurasi \nCC=icc CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\nlibpng\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf libpng-1.6.37.tar.gz\n# 2. Buka folder hasil ekstrak\ncd libpng-1.6.37\n# 3. Konfigurasi \nCC=icc CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\njasper\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf jasper-1.900.1.tar.gz  \n# 2. Buka folder hasil ekstrak\ncd jasper-1.900.1\n# 3. Konfigurasi \nCC=icc CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR\n# 4. Instalasi\nmake check install\nhdf5\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf hdf5-1.12.0.tar.gz \n# 2. Buka folder hasil ekstrak\ncd hdf5-1.12.0\n# 3. Konfigurasi \nCC=icc FC=ifort CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR --with-default-api-version=v18 --enable-fortran\n# 4. Instalasi\nmake\nmake install\nnetcdf-c\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf netcdf-c-4.7.4.tar.gz \n# 2. Buka folder hasil ekstrak\ncd netcdf-c-4.7.4\n# 3. Konfigurasi \nCC=icc CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR --disable-dap\n# 4. Instalasi\nmake\nmake install\nnetcdf-fortran\n# 0. Buka folder libraries\ncd $ODIR/pyWRF-install/libraries\n# 1. Extract \ntar -xf netcdf-fortran-4.5.3.tar.gz \n# 2. Buka folder hasil ekstrak\ncd netcdf-fortran-4.5.3\n# 3. Konfigurasi \nCC=icc FC=ifort CFLAGS='-diag-disable=10441' ./configure --prefix=$ODIR\n# 4. Instalasi\nmake\nmake install\n\n\n\n\n2.3.6 Instalasi WRF\nProses instalasi WRF membutuhkan waktu agak lama, yaitu sekitar 30-60 menit. Tentunya, ini bergantung pada spesifikasi prosesor yang Anda gunakan, serta tipe Compiler. Ikuti langkah-langkah berikut.\n\nBuka direktori WRF yang berada di dalam $ODIR/WRF dengan perintah.\ncd $ODIR/WRF\nJalankan file configure dengan perintah.\n./configure\nAnda akan disajikan beberapa teks di dalamnya. Anda disuruh untuk memilih opsi Compiler. Tipe Compiler tersebut selain GNU dan Intel, ada pula IBM, PGI, Fujitsu, Pathscale, dan CRAY. Jika Anda menggunakan Compiler tipe GNU, ketikkan angka 35. Untuk Intel, ketik angka 16. Setelah itu, tekan Enter.\n\n\nUntuk melakukan instalasi, ketik perintah ini.\n./compile em_real -j jumlah_prosesor\ndimana jumlah_prosesor adalah jumlah dari prosesor pada laptop/komputer Anda yang akan digunakan untuk proses instalasi dan kompilasi kode-kode WRF. Proses kompilasi akan memakan waktu yang sangat lama apabila Anda hanya menggunakan 1 prosesor. Pastikan berbagai program pada komputer/laptop Anda yang saat ini sedang dibuka, seperti Google Chrome atau Spotify harap ditutup terlebih dahulu karena ini membantu proses instalasi lebih stabil.\nUntuk Compiler Intel, setelah langkah ke-2 dijalankan, buka file configure.wrf dengan perintah.\nnano configure.wrf\nKemudian, scroll ke bawah dengan menekan tombol \\(\\downarrow\\) pada keyboard dan ubahlah isinya sesuai aturan pada tabel di bawah ini.\n\n\nTabel 2.1: Pengubahan variabel DM_FC dan DM_CC\n\n\nSebelum\nSesudah\n\n\n\n\nDM_FC = mpif90 -f90=$(SFC)\nDM_FC = mpiifort -f90=$(SFC)\n\n\nDM_CC = mpicc -cc=$(SCC)\nDM_CC = mpiicc -cc=$(SCC)\n\n\n\n\nSetelah selesai diubah, keluar dari editor nano dengan menekan tombol Ctrl + X\n\nProses instalasi WRF berhasil dilakukan apabila terdapat file yang berekstensi .exe: ndown.exe, tc.exe, real.exe, dan wrf.exe di dalam folder main. Anda bisa melihatnya dengan perintah\nls main/*.exe\nmain/ndown.exe  main/real.exe  main/tc.exe  main/wrf.exe\nUntuk pengguna MacOS M1/M2 dengan Docker, ikuti langkah-langkah berikut.\n\nBuka direktori WRF yang berada di dalam $ODIR/WRF.\nUbah file arch/configure.defaults menggunakan teks editor nano dengan menambahkan teks ini.\nnano arch/configure.defaults\n########################################################################################################################\n#ARCH Linux aarch64, Arm compiler OpenMPI # serial smpar dmpar dm+sm#\nDESCRIPTION     =      GCC ($SFC/$SCC): Aarch64\nDMPARALLEL      =\nOMPCPP          =      -fopenmp\nOMP             =      -fopenmp\nOMPCC           =      -fopenmp\nSFC             =      gfortran\nSCC             =      gcc\nCCOMP           =      gcc\nDM_FC           =      mpif90\nDM_CC           =      mpicc -DMPI2_SUPPORT\nFC              =      CONFIGURE_FC\nCC              =      CONFIGURE_CC\nLD              =      $(FC)\nRWORDSIZE       =      CONFIGURE_RWORDSIZE\nPROMOTION       =\nARCH_LOCAL      =\nCFLAGS_LOCAL    =      -w -O3 -c\nLDFLAGS_LOCAL   =      -fopenmp\nFCOPTIM         =      -Ofast -march=armv8.2-a+fp16+rcpc+dotprod+crypto -fopenmp -frecursive -funroll-loops\nFCREDUCEDOPT    =      $(FCOPTIM)\nFCNOOPT         =      -O0 -fopenmp -frecursive\nFCDEBUG         =      -g $(FCNOOPT)\nFORMAT_FIXED    =      -ffixed-form -ffixed-line-length-0 -Wno-invalid-pch -Wno-argument-mismatch\nFORMAT_FREE     =      -ffree-form -ffree-line-length-0 -Wno-argument-mismatch -Wno-invalid-pch\nFCSUFFIX        =\nBYTESWAPIO      =      -fconvert=big-endian -frecord-marker=4\nFCBASEOPTS      =      -w $(FORMAT_FREE) $(BYTESWAPIO)\nMODULE_SRCH_FLAG=      -I$(WRF_SRC_ROOT_DIR)/main\nTRADFLAG        =      -traditional-cpp\nCPP             =      /lib/cpp CONFIGURE_CPPFLAGS\nAR              =      ar\nARFLAGS         =      ru\nM4              =      m4 -B 14000\nRANLIB          =      ranlib\nRLFLAGS         =\nCC_TOOLS        =      $(SCC)\nJalankan program configure dengan perintah ini.\n./configure\nKemudian, pilih nomor 4 untuk memilih opsi Linux aarch64, Arm compiler OpenMPI # serial smpar dmpar dm+sm. Setelah itu, tekan Enter. Abaikan saja terhadap respons seperti pada gambar ini.\n\nSelanjutnya, jalankan program compile dengan perintah ini.\n./compile em_real -j jumlah_prosesor\n\n\n\n2.3.7 Instalasi WRF Pre-Processing (WPS)\nProgram WPS digunakan untuk menyesuaikan data masukan dari berbagai sumber (ERA5, GFS, NAM, …) sebelum ke simulasi WRF. Terdapat 3 program utama: geogrid.exe, ungrib.exe, dan metgrid.exe.\n\ngeogrid.exe: memilih lokasi yang akan dilakukan simulasi. Luaran program ini berupa file geo_em* yang berisi nilai-nilai dari variabel di dalam file hasil ekstrak geog_high_res_mandatory.tar\nungrib.exe: mengubah file berformat grib menjadi nc, serta memungkinkan dapat melakukan interpolasi (waktu dan lokasi)\nmetgrid.exe: menggabungkan luaran dari geogrid.exe dan ungrib.exe sehingga menghasilkan file met_em* sesuai dengan ketentuan lokasi dan waktu di dalam namelist.wps\n\nProses instalasi WPS tidak membutuhkan waktu yang lama, sekitar 2-5 menit. Untuk melakukan instalasi WPS, ikuti langkah-langkah berikut ini.\n\nSaat ini, Anda berada di folder WRF. Buka folder WPS dengan perintah ini.\ncd $ODIR/WPS\nJalankan file configure dengan perintah ini.\n./configure\nKetik angka 3 untuk GNU atau angka 19 untuk Intel.\nSetelah selesai, di folder WPS akan muncul file configure.wps. Beberapa baris dari isi file tersebut ada yang perlu ditambahkan dan diganti dengan ketentuan ini.\n\nUntuk Intel, tambahkan flags -liomp5 setelah -lnetcdf pada bagian variabel WRF_LIB = .... Kemudian, ubah pula DM_FC dan DM_CC seperti pada Tabel 2.1.\nUntuk GNU, tambahkan flags -lgomp setelah -lnetcdf pada bagian variabel WRF_LIB = ....\n\nSetelah diganti, lakukan kompilasi dengan mengetik perintah\n./compile\n\nProses instalasi berhasil apabila terdapat 3 file .exe: geogrid.exe, ungrib.exe, dan metgrid.exe di folder WPS yang berupa shortcut. Anda dapat menggunakan perintah\nls *.exe\ngeogrid.exe  metgrid.exe  ungrib.exe\nUntuk pengguna MacOS M1/M2 dengan Docker, ikuti langkah-langkah berikut.\n\nBuka direktori WPS yang berada di dalam $ODIR/WPS.\nUbah file arch/configure.defaults menggunakan teks editor nano dengan menambahkan teks ini.\nnano arch/configure.defaults\n########################################################################################################################\n#ARCH Linux aarch64, Arm compiler OpenMPI # serial smpar dmpar dm+sm#\nCOMPRESSION_LIBS    = CONFIGURE_COMP_L\nCOMPRESSION_INC     = CONFIGURE_COMP_I\nFDEFS               = CONFIGURE_FDEFS\nSFC                 = gfortran\nSCC                 = gcc\nDM_FC               = mpif90\nDM_CC               = mpicc\nFC                  = CONFIGURE_FC\nCC                  = CONFIGURE_CC\nLD                  = $(FC)\nFFLAGS              = -ffree-form -O -fconvert=big-endian -frecord-marker=4 -ffixed-line-length-0 -Wno-argument-mismatch -Wno-invalid-pch\nF77FLAGS            = -ffixed-form -O -fconvert=big-endian -frecord-marker=4 -ffree-line-length-0 -Wno-argument-mismatch -Wno-invalid-pch\nFCSUFFIX            =\nFNGFLAGS            = $(FFLAGS)\nLDFLAGS             =\nCFLAGS              =\nCPP                 = /usr/bin/cpp -P -traditional\nCPPFLAGS            = -D_UNDERSCORE -DBYTESWAP -DLINUX -DIO_NETCDF -DBIT32 -DNO_SIGNAL CONFIGURE_MPI\nRANLIB              = ranlib\nJalankan program configure dengan perintah ini. Kemudian, pilih nomor 2. Tetap abaikan respons pada tulisan ./configure: 1: file: not found\n./configure\nKemudian, ubah isi file configure.wps dengan menambahkan flags -lgomp setelah -lnetcdf pada variabel WRF_LIB = ....\nSelanjutnya, jalankan program compile dengan perintah ini.\n./compile"
  },
  {
    "objectID": "praktikum-1.html#menjalankan-simulasi-wrf-arw",
    "href": "praktikum-1.html#menjalankan-simulasi-wrf-arw",
    "title": "2  Dynamical Downscaling: Model Weather Research Forecasting (WRF)",
    "section": "2.4 Menjalankan Simulasi WRF-ARW",
    "text": "2.4 Menjalankan Simulasi WRF-ARW\nAnda dapat melanjutkan ke tahapan ini apabila seluruh program telah berhasil terpasang. Bagi Anda yang belum berhasil, sabar :D dan ulangi kembali langkah-langkah di atas. Secara umum, diagram pada Gambar 2.9 menunjukkan proses menjalankan WRF dari tahapan memasukkan data hingga plot dan analisis akhir. Seperti yang telah dijelaskan pada subbab sebelumnya bahwa langkah awal dalam menjalankan WRF adalah menjalankan WPS terlebih dahulu. Anda perlu menyiapkan data masukan atmosfer maupun permukaan (data statik). Program geogrid.exe dijalankan pertama, kemudian diikuti dengan ungrib.exe dan terakhir metgrid.exe. Selanjutnya, Anda dapat melangkah ke program WRF, yaitu real.exe dan wrf.exe. Program real.exe digunakan sebagai pendefinisian kondisi awal dan kondisi batas berdasarkan informasi dari namelist.input yang berada dalam folder test/em_real/. Kemudian, Anda dapat menggunakan perangkat lunak apapun (mis. NCAR Command Language (NCL), GrADS, R, Python, Julia, Matlab, ArcMAP, atau QGIS) untuk menganalisis serta visualisasi luaran WRF.\nUntuk data masukan, Anda juga dapat menggunakan data observasi, tetapi harus berupa grid. Namun, ini merupakan program yang berbeda dari WRF-ARW, yaitu WRFDA (WRF Data Assimilation). Selain itu, terdapat pula data masukan dari emisi kimia, seperti emisi biogenik dan atropogenik. Akan tetapi, program ini merupakan turunan WRF-ARW, yaitu WRF-Chem. Penjelasan mengenai WRFDA dan WRF-Chem tidak disampaikan di dalam praktikum ini.\n\n\n\nGambar 2.9: Diagram WRF\n\n\nJika Anda menutup terminal bash atau mematikan laptop/komputer, definisikan kembali ENVIRONMENT VARIABLE seperti pada saat proses memasang WRF dan WPS. Variabel yang perlu didefinisikan hanya 3 saja seperti pada perintah di bawah ini. Anda dapat memasukkan variabel ini pada file .bashrc atau .bash_profile di direktori $HOME.\nexport ODIR=$HOME/WRF-Model\nexport PATH=$ODIR/bin:$PATH\nexport LD_LIBRARY_PATH=$ODIR/lib:$LD_LIBRARY_PATH\nBagi pengguna Compiler Intel, Anda perlu menambahkan perintah di bawah ini. Perintah ini diperlukan pada saat menjalankan WRF.\nulimit -s unlimited\n\n2.4.1 Program WPS\nUntuk lebih mudah dalam memahami alur proses simulasi WRF pada modul ini, lokasi/domain yang dipilih untuk adalah Kota Surabaya dengan periode 1-3 Januari 2022 dengan data GFS dan ERA5. Interval waktu dari kedua data tersebut adalah 6 jam, yaitu pukul 00:00, 06:00, 12:00, dan 18:00 waktu Zulu (UTC+0). Langkah awal sebelum menjalankan WRF adalah menentukan lokasi dan waktu terlebih dahulu di dalam program WPS. Seperti yang telah dijelaskan sebelumnya, WPS memiliki 3 program utama: geogrid.exe, ungrib.exe, dan metgrid.exe.\nSesuai dengan kelanjutan dari subbab sebelumnya mengenai instalasi WRF, Anda saat ini berada di dalam folder WPS/. Jika lupa, Anda bisa mengetikkan kembali perintah ini.\ncd $ODIR/WPS\nLangkah-langkah menjalankan program WPS adalah sebagai berikut.\n\n2.4.1.1 Penentuan Lokasi dan Waktu Simulasi\nIsi dari file namelist.wps pada saat awal instalasi seperti ini.\n&share\n wrf_core = 'ARW',\n max_dom = 2,\n start_date = '2019-09-04_12:00:00','2019-09-04_12:00:00',\n end_date   = '2019-09-06_00:00:00','2019-09-04_12:00:00',\n interval_seconds = 10800\n/\n\n&geogrid\n parent_id         =   1,    1,\n parent_grid_ratio =   1,    3,\n i_parent_start    =   1,   53,\n j_parent_start    =   1,   25,\n e_we              =  150, 220,\n e_sn              =  130, 214,\n geog_data_res = 'default','default',\n dx = 15000,\n dy = 15000,\n map_proj = 'lambert',\n ref_lat   =  33.00,\n ref_lon   = -79.00,\n truelat1  =  30.0,\n truelat2  =  60.0,\n stand_lon = -79.0,\n geog_data_path = '/glade/work/wrfhelp/WPS_GEOG/'\n/\n\n&ungrib\n out_format = 'WPS',\n prefix = 'FILE',\n/\n\n&metgrid\n fg_name = 'FILE'\n/\nTerdapat berbagai macam parameter di dalam &share, &geogrid, &ungrib, dan &metgrid. Anda perlu mengubah beberapa parameter tersebut yang dapat disesuaikan dengan simulasi. Tapi, Anda harus memperhatikan aturan atau template yang telah diberikan di dalam panduan pengguna. Untuk lebih rincinya, Anda bisa lihat di Panduan Pengguna WRF-ARW Bab 3. Di dalam tahapan ini, Anda perlu mengubah parameter-parameter yang ada di dalam &geogrid. Pada contoh yang telah kami berikan, Anda perlu mengganti parameter pada bagian &share dan &geogrid di dalam file namelist.wps. Anda dapat menggunakan teks editor nano.\nnano namelist.wps\nFile yang telah berubah menjadi seperti di bawah ini.\n&share\n wrf_core = 'ARW',                                                                 \n max_dom = 3,\n start_year  = 2022, 2022, 2022,\n start_month =   01,   01,   01,\n start_day   =   01,   01,   01,\n start_hour  =   00,   00,   00,\n end_year    = 2022, 2022, 2022,\n end_month   =   01,   01,   01,\n end_day     =   03,   03,   03,\n end_hour    =   18,   18,   18,\n interval_seconds = 21600,                                                         \n io_form_geogrid = 2,                                                              \n/\n\n&geogrid\n parent_id         =   1,   1,   1,\n parent_grid_ratio =   1,   3,   9,                                                  \n i_parent_start    =   1,  11,  15,\n j_parent_start    =   1,  11,  15,\n e_we              =  33,  40,  46,                                                 \n e_sn              =  33,  40,  46,                                                 \n geog_data_res = 'default','default','default',                                     \n dx = 18000,                                                                        \n dy = 18000,                                                                        \n map_proj = 'mercator',                                                             \n ref_lat   =  -7.328,                                                   \n ref_lon   = 112.741,                                                     \n truelat1  =  -7.328,                                                   \n geog_data_path = '/home/absen/WRF-Model/data/WPS_GEOG/'                                 \n/\n\n&ungrib\n out_format = 'WPS',\n prefix = 'FILE',\n/\n\n&metgrid\n fg_name = 'FILE'\n io_form_metgrid = 2, \n/\nPenjelasan setiap variabel dapat dilihat pada Tabel 2.2.\n\n\nTabel 2.2: Informasi beberapa variabel di dalam namelist.wps\n\n\n\n\n\n\nVariabel\nKeterangan\n\n\n\n\nwrf_core\nTipe penyelesaian WRF, ARW atau NMM\n\n\nmax_dom\nJumlah domain, semakin banyak domain maka semakin tinggi resolusi spasialnya\n\n\nstart_date\nWaktu mulai simulasi sesuai dengan data masukan. Format: YYYY-MM-DD_HH:mm:ss\n\n\nend_date\nWaktu akhir simulasi sesuai dengan data masukan. Format: YYYY-MM-DD_HH:mm:ss\n\n\ninterval_seconds\nInterval waktu dari data masukan (dalam detik)\n\n\nio_from_geogrid\nTipe format file luaran geogrid.exe (1 = binary, 2 = netcdf, 3 = GRIB1)\n\n\nparent_id\nUntuk domain paling kasar, nilainya 1. Domain selanjutnya juga bernilai 1 yang menandakan bahwa subdomain merupakan bagian dari domain utamanya\n\n\nparent_grid_ratio\nRasio piksel dari dx dan dy pada domain ke-1. Domain paling kasar adalah 1 dan selanjutnya mengikuti rasio yang diinginkan.\n\n\ni_parent_start\nNomor indeks acuan untuk koordinat X. Domain paling kasar bernilai 1, ditentukan dari kiri-bawah\n\n\nj_parent_start\nNomor indeks acuan untuk koordinat Y. Domain paling kasar bernilai 1, ditentukan dari kiri-bawah\n\n\ne_we\nJumlah grid/piksel dari barat ke timur mengikuti rumus parent_grid_ratio * N + 1, dengan \\(N &gt; 0\\)\n\n\ne_sn\nJumlah grid/piksel dari selatan ke utara mengikuti rumus parent_grid_ratio * N + 1, dengan \\(N &gt; 0\\)\n\n\ngeog_data_res\nPemilihan resolusi spasial dari data statik\n\n\ndx\nResolusi spasial pada koordinat X (dalam meter)\n\n\ndy\nResolusi spasial pada koordinat Y (dalam meter)\n\n\nmap_proj\nSistem proyeksi peta (mercator, lambert, polar, lat-lon). Untuk simulasi di sekitar khatulistiwa, direkomendasikan menggunakan mercator\n\n\nref_lat\nKoordinat lintang titik tengah acuan dari domain paling kasar\n\n\nref_lon\nKoordinat bujur titik tengah acuan dari domain paling kasar\n\n\ntruelat1\nKoordinat lintang sebenarnya. Dibutuhkan untuk sistem proyeksi mercator, polar, dan lambert\n\n\ngeog_data_path\nLokasi folder WPS_GEOG\n\n\n\n\nPada parameter start_date dan end_date, Anda bisa menggunakan parameter lain dengan membagi masing-masing format tahun (start_year; end_year), bulan (start_month; end_month), tanggal (start_day; end_day), dan jam (start_hour; end_hour).\nBerkaitan dengan skala resolusi spasial pada simulasi yang akan dijalankan dengan pemilihan lokasi di Kota Surabaya, skala tertingginya adalah 2 km. Anda perhatikan parameter parent_grid_ratio. Nilai 1, 3, dan 9 secara berturut-turut merupakan rasio terhadap dx atau dy untuk setiap domain. Nilai 1 berarti untuk domain terluar dengan skala \\(1 / 1 * 18000 = 18000\\) meter, sedangkan nilai 3 untuk domain ke-2 dengan skala \\(1 / 3 * 18000 = 6000\\) meter.\nPada bagian &geogrid, penentuan lokasi kajian ini cukup rumit. Anda bisa menggunakan halaman Github https://jiririchter.github.io/WRFDomainWizard untuk membuat file namelist.wps sesuai dengan lokasi yang Anda inginkan, setidaknya Anda dapat menyalin teks pada bagian &geogrid Gambar 2.10.\n\n\n\nGambar 2.10: WRF Domain Wizard oleh Jiririchter\n\n\nUntuk memverifikasi kesesuaian pemilihan lokasi yang telah dibuat, Anda dapat menggunakan skrip plotgrids_new.ncl di dalam folder util/. Bukalah file tersebut. Cari dan ubahlah variabel type = x11 menjadi type = png untuk mengatur luaran file dalam bentuk gambar (format .png). Untuk menjalankan skrip ini, aktifkan terlebih dahulu environment ncl dengan perintah source activate ncl atau conda activate ncl. Kemudian, jalankan perintah berikut ini. File .png akan muncul di dalam folder WPS/ dengan nama wps_show_dom.png. Hasilnya seperti Gambar 2.11\ncd $HOME/WRF-Model/WPS\nncl util/plotgrids_new.ncl\n\n\n\nGambar 2.11: Konfigurasi domain WRF\n\n\n\n\n2.4.1.2 Menjalankan Program geogrid.exe\nSelanjutnya, Anda dapat menjalankan program geogrid.exe dengan perintah di bawah ini. Hasilnya, terdapat 3 file dengan nama geo_em.d0x.nc (dengan x = nomor domain; 1, 2, 3) karena pengaturan max_dom = 3.\n./geogrid.exe\nls geo_em*\ngeo_em.d01.nc  geo_em.d02.nc  geo_em.d03.nc\n\n\n2.4.1.3 Menyambungkan File Data Masukan dan Tabel Variabel\nWPS menyediakan program link_grib.csh untuk menyambungkan file data masukan ke dalam folder WPS/ dengan membuat shortcut yang bernama GRIBFILE.* (GRIBFILE.AAA, GRIBFILE.AAB, …). Perintahnya sebagai berikut.\n./link_grib.csh $ODIR/data/GFS/*\nKemudian, buatlah shortcut dengan nama Vtable di dalam folder WPS/ dari file yang berada di dalam folder ungrib/Variable_Tables. Untuk data GFS, nama file tersebut adalah Vtable.GFS, sedangkan ERA5 adalah Vtable.ERA-Interim.pl. Perintahnya sebagai berikut.\nln -sf ungrib/Variable_Tables/Vtable.GFS Vtable # GFS\nln -sf ungrib/Variable_Tables/Vtable.ERA-Interim.pl Vtable # ERA5\n\n\n2.4.1.4 Menjalankan Program ungrib.exe\nSetelah menyambungkan data masukan serta tabel variabel, jalankan program ungrib.exe dengan perintah berikut.\n./ungrib.exe\nLuaran dari program ini adalah file dengan nama FILE:* yang memiliki format .nc (netcdf).\n\n\n2.4.1.5 Menjalankan Program metgrid.exe\nJalankan program metgrid.exe dengan perintah berikut.\n./metgrid.exe\nLuaran dari program ini adalah file dengan nama met_em* yang memiliki format .nc. File-file ini nanti yang akan dipindahkan menuju folder WRF/test/em_real atau Anda dapat juga membuat shortcut. Perintahnya sebagai berikut.\nmv met_em* $ODIR/WRF/test/em_real # memindahkan semua file met_em* ke folder WRF/test/em_real\n# atau\nln -sf met_em* $ODIR/WRF/test/em_real # membuat shortcut di folder WRF/test/em_real\n\n\n\n2.4.2 Program WRF\nPada bagian ini, program WRF yang digunakan hanya 2: real.exe dan wrf.exe. Sebelum itu, Anda diharuskan mengubah beberapa parameter pada file namelist.input seperti di dalam file namelist.wps. Parameter di dalam namelist.input sangat banyak karena terdapat bagian pemilihan lokasi dan waktu (disesuaikan dengan namelist.wps), pemilihan skema parameter fisik, dan parameter dinamik. Kami hanya memberikan beberapa parameter yang diperlukan untuk contoh simulasi. Anda dapat membaca lebih lanjut di Panduan Pengguna WRF Bab 5.\n\n2.4.2.1 Mengubah isi namelist.input\nSaat ini Anda masih berada di folder WPS/. Buka terlebih dahulu folder em_real dengan perintah\ncd $ODIR/WRF/test/em_real\nDi dalam folder em_real, terdapat 4 program, yaitu real.exe, ndown.exe, tc.exe, dan wrf.exe. Nilai max_dom pada namelist.wps adalah 3. Jika pemilihan lokasi Anda memiliki &gt;1 domain, WRF akan memproses simulasi sampai pada domain tertinggi atau disebut dengan nesting. Proses ini juga dibagi lagi menjadi 2, yaitu nesting dua arah dan satu arah. Untuk nesting satu arah, program yang digunakan bisa atau tanpa dengan program ndown.exe. Penggunaan nesting satu arah biasanya pengguna hanya tertarik pada analisis domain tertinggi. Penggunaan ndown.exe juga sering digunakan pada turunan WRF, yaitu WRF-Chem. Untuk nesting dua arah, proses-proses perhitungan fisis pada domain tertinggi akan dikembalikan (feedback) ke domain terendah sehingga proses analisis dapat dilakukan pada semua domain. Anda dapat membaca lebih lanjut mengenai nesting di https://ruc.noaa.gov/wrf/wrf-chem/wrf_tutorial_2012_brazil/WRF_nesting.pdf.\nBukalah file namelist.input dengan cara sama seperti Anda membuka namelist.wps. Ketika pertama kali dibuka, file namelist.input seperti di bawah ini. Anda juga dapat melihat beberapa contoh/template lain (mis. namelist.input.4km, namelist.input.chem, namelist.input.volc, …) sesuai dengan kebutuhan tertentu.\n &time_control\n run_days                            = 0,\n run_hours                           = 36,\n run_minutes                         = 0,\n run_seconds                         = 0,\n start_year                          = 2019, 2019,\n start_month                         = 09,   09, \n start_day                           = 04,   04,\n start_hour                          = 12,   12,\n end_year                            = 2019, 2019,\n end_month                           = 09,   09,\n end_day                             = 06,   06,\n end_hour                            = 00,   00,\n interval_seconds                    = 10800\n input_from_file                     = .true.,.true.,\n history_interval                    = 60,  60,\n frames_per_outfile                  = 1, 1,\n restart                             = .false.,\n restart_interval                    = 7200,\n io_form_history                     = 2\n io_form_restart                     = 2\n io_form_input                       = 2\n io_form_boundary                    = 2\n /\n\n &domains\n time_step                           = 90,\n time_step_fract_num                 = 0,\n time_step_fract_den                 = 1,\n max_dom                             = 2,\n e_we                                = 150,    220,\n e_sn                                = 130,    214,\n e_vert                              = 45,     45,\n dzstretch_s                         = 1.1\n p_top_requested                     = 5000,\n num_metgrid_levels                  = 34,\n num_metgrid_soil_levels             = 4,\n dx                                  = 15000,\n dy                                  = 15000,\n grid_id                             = 1,     2,\n parent_id                           = 0,     1,\n i_parent_start                      = 1,     53,\n j_parent_start                      = 1,     25,\n parent_grid_ratio                   = 1,     3,\n parent_time_step_ratio              = 1,     3,\n feedback                            = 1,\n smooth_option                       = 0\n /\n\n &physics\n physics_suite                       = 'CONUS'\n mp_physics                          = -1,    -1,\n cu_physics                          = -1,    -1,\n ra_lw_physics                       = -1,    -1,\n ra_sw_physics                       = -1,    -1,\n bl_pbl_physics                      = -1,    -1,\n sf_sfclay_physics                   = -1,    -1,\n sf_surface_physics                  = -1,    -1,\n radt                                = 15,    15,\n bldt                                = 0,     0,\n cudt                                = 0,     0,\n icloud                              = 1,\n num_land_cat                        = 21,\n sf_urban_physics                    = 0,     0,\n fractional_seaice                   = 1,\n /\n\n &fdda\n /\n\n &dynamics\n hybrid_opt                          = 2, \n w_damping                           = 0,\n diff_opt                            = 2,      2,\n km_opt                              = 4,      4,\n diff_6th_opt                        = 0,      0,\n diff_6th_factor                     = 0.12,   0.12,\n base_temp                           = 290.\n damp_opt                            = 3,\n zdamp                               = 5000.,  5000.,\n dampcoef                            = 0.2,    0.2,\n khdif                               = 0,      0,\n kvdif                               = 0,      0,\n non_hydrostatic                     = .true., .true.,\n moist_adv_opt                       = 1,      1,\n scalar_adv_opt                      = 1,      1,\n gwd_opt                             = 1,      0,\n /\n\n &bdy_control\n spec_bdy_width                      = 5,\n specified                           = .true.\n /\n\n &grib2\n /\n\n &namelist_quilt\n nio_tasks_per_group = 0,\n nio_groups = 1,\n /\nPada file ini, samakan beberapa parameter seperti di file namelist.wps. Perhatikan Tabel 2.3. Anda cukup mencari parameter yang sama antara namelist.wps dengan namelist.input, tetapi tidak semuanya ada di dalam namelist.input. Untuk parameter lainnya, seperti parent_time_step_ratio, time_step, history_interval, frame_per_outfile, dan seterusnya, Anda dapat membacanya lebih banyak di Panduan Pengguna WRF Bab 5 atau bisa dilihat pada file README.namelist di dalam folder test/em_real untuk setiap penjelasan singkat berbagai parameter.\nBagian &time_control berfungsi sebagai pengaturan waktu simulasi serta luaran yang akan dihasilkan. Sebagai informasi, file luaran WRF berformat NetCDF (.nc) dengan nama\nwrfout_&lt;domain&gt;_&lt;yyyy&gt;-&lt;mm&gt;-&lt;dd&gt;_&lt;HH&gt;:&lt;MM&gt;:&lt;SS&gt;, dimana\n\ndomain: identitas domain (d01, d02, …)\nyyyy: tahun, dengan format 4 digit\nmm: bulan, dengan format 2 digit\ndd: tanggal, dengan format 2 digit\nHH: jam, dengan format 2 digit\nMM: menit, dengan format 2 digit\nSS: detik, dengan format 2 digit\n\nPada parameter run_days, run_hours, run_minutes, dan run_seconds, ini dapat dihitung dari selisih waktu akhir simulasi dengan awal simulasi. Pada simulasi yang akan dicoba dalam modul ini, yaitu 1 Januari 2022 pukul 00:00 UTC hingga 3 Januari 2022 18:00 UTC, nilai dari run_days dan run_hours secara berturut-turut adalah 2 dan 18. Anda juga dapat mengatur run_days ini menjadi 0 setelah dikonversi menjadi jam (2 hari = 48 jam) dan tambahkan ke run_hours, yaitu menjadi 66. Parameter history_interval digunakan untuk meletakkan nilai pada file luaran WRF dalam format .nc dengan waktu tertentu (dalam menit). Misalkan diatur ke 60, berarti hasil perhitungan dari berbagai algoritma WRF dimasukkan ke file setiap 60 menit sekali. Anda bebas mengatur angka pada parameter ini. Dampaknya, ukuran file akan semakin besar jika Anda mengatur nilainya kecil. Tentu ini tidak akan menjadi masalah apabila ruang kosong penyimpanan internal/eksternal Anda masih banyak. Banyaknya file luaran dapat pula diatur jumlahnya, yaitu di dalam parameter frames_per_outfile. Jika parameter diatur pada frames_per_outfile = 1, history_interval = 60, dan run_hours = 66, berarti file luaran yang akan dibuat dan disimpan ke dalam penyimpanan adalah sebanyak 66 file. Agar lebih efektif saat akan melakukan analisis, kami menyarankan untuk mengatur frames_per_outfile = 1000.\nKemudian untuk bagian &domains, digunakan untuk mengatur kondisi dari domain agar dapat sesuai dengan data masukan (banyak grid horizontal dan vertikal, posisi, rasio grid, tipe interpolasi). Pada parameter feedback, Anda dapat mengatur tipe nesting dua arah (1) atau satu arah (0). Parameter num_metgrid_levels dan num_metgrid_soil_levels harus diatur sesuai dengan yang ada di dalam salah satu file met_em*. Untuk melihatnya, gunakan perintah di bawah ini. Nilai kedua parameter num_metgrid_levels dapat berbeda sesuai dengan data masukan yang digunakan. Sebagai contoh, GFS memiliki num_metgrid_levels = 34, sedangkan ERA5 num_metgrid_levels = 38.\nncdump -h met_em.d01.2022-01-01_00:00:00.nc | grep num_metgrid_levels      # = 34\nncdump -h met_em.d01.2022-01-01_00:00:00.nc | grep NUM_METGRID_SOIL_LEVELS # = 4\nDi dalam bagian &physics, terdapat berbagai skema parameterisasi dalam penyelesaian perhitungan pembentukan awan, skemar radiasi, lapisan perbatas, serta proses-proses di permukaan tanah. Pada parameter physics_suite, Anda bisa mengaturnya ke TROPICAL karena wilayah yang ingin disimulasikan berada di daerah tropis. Hanya saja, opsi default untuk skema parameterisasi belum tentu menghasilkan luaran yang bagus sesuai dengan kondisi sebenarnya di daerah tropis. Anda perlu mengkaji dari beberapa publikasi nasional maupun internasional dalam memilih skema parameterisasi, khususnya di wilayah Indonesia. Ketika Anda mendefinisikan physics_suite = 'TROPICAL', Anda tidak perlu lagi menambahkan angka pada parameter di bawah ini.\n\nmp_physics         =  6: WSM6\ncu_physics         = 16: New-Tiedke\nra_lw_physics      =  4: Rapid Radiative Model Transformation for GCM (RRTMG)\nra_sw_physics      =  4: Rapid Radiative Model Transformation for GCM (RRTMG)\nbl_pbl_physics     =  1: Yonsei University\nsf_sfclay_physics  = 91: MM5 Monin-Obukhov\nsf_surface_physics =  2: Noah Land Surface Model\n\nAnda hanya perlu menambahkan nilai -1 pada parameter-parameter tersebut, tentu saja sesuai dengan banyaknya domain. Anda juga dapat menghilangkan parameter physics_suite dan mengganti parameter mp_physics, cu_physics, sf_surface_physics, sf_sfclay_physics, ra_lw_physics, ra_sw_physics, dan bl_pbl_physics ke opsi lain yang ada di dalam Panduan Pengguna WRF Bab 5. Anda harus berhati-hati dan memperhatikan pemilihan skema parameterisasi karena terdapat parameter yang harus ditambahkan di dalam bagian &physics, menambahkan bagian lain, atau kombinasi antar skema. Sebagai contoh untuk sf_surface_physics = 4 (Noah-MP Land Surface Model), perlu menambahkan bagian &noah_mp; Ketika cu_physics = 14 (Scale-aware SAS), perlu menambahkan parameter shcu_physics = 4; Parameter bl_pbl_physics = 2 (Mellor-Yamada-Janjic, MYJ) nilai dari parameter sf_sfclay_physics = 2 (Eta Model). Untuk pengaturan nilai-nilai di dalam &physics, Anda harus menambahkannya sebanyak jumlah domain. Anda juga dapat menonaktifkan skema parameterisasi tertentu dengan mengubahnya ke 0, misalnya pada cu_physics untuk domain &lt;10 km (domain 2 dan 3).\n\n\nTabel 2.3: Informasi sebagian variabel di dalam namelist.input yang perlu disesuaikan dengan namelist.wps\n\n\n\n\n\n\nParameter di namelist.wps\nParameter di namelist.input\n\n\n\n\nstart_year = 2022, 2022, 2022,\nstart_year = 2022, 2022, 2022,\n\n\nstart_month = 01, 01, 01,\nstart_month = 01, 01, 01,\n\n\nstart_day = 01, 01, 01,\nstart_day = 01, 01, 01,\n\n\nstart_hour = 00, 00, 00,\nstart_hour = 00, 00, 00,\n\n\nend_year = 2022, 2022, 2022,\nend_year = 2022, 2022, 2022,\n\n\nend_month = 01, 01, 01,\nend_month = 01, 01, 01,\n\n\nend_day = 03, 03, 03,\nend_day = 03, 03, 03,\n\n\nend_hour = 18, 18, 18,\nend_hour = 18, 18, 18,\n\n\n-\nrun_days = 2,\n\n\n-\nrun_hour = 18,\n\n\nmax_dom = 3,\nmax_dom = 3,\n\n\ninterval_seconds = 21600,\ninterval_seconds = 21600,\n\n\nparent_id = 1, 1, 1,\nparent_id = 1, 1, 1,\n\n\nparent_grid_ratio =   1,   3,   9,\nparent_grid_ratio =   1,   3,   9,\n\n\ndx = 15000,\ndx = 15000,\n\n\ndy = 15000,\ndy = 15000,\n\n\ni_parent_start = 1,  11,  15,\ni_parent_start = 1,  11,  15,\n\n\nj_parent_start = 1,  11,  15,\nj_parent_start = 1,  11,  15,\n\n\ne_we =  33,  40,  46,\ne_we =  33,  40,  46,\n\n\ne_sn =  33,  40,  46,\ne_sn =  33,  40,  46,\n\n\n-\nparent_time_step_ratio = 1,   3,   9, (sama dengan parent_grid_ratio)\n\n\n-\ntime_step = 90, dengan rumus \\(6 * dx\\) (dalam km)\n\n\n\n\nIsi file namelist.input yang telah diubah sepenuhnya menjadi seperti ini.\n&time_control\n run_days                            = 2,\n run_hours                           = 18,\n run_minutes                         = 0,\n run_seconds                         = 0,\n start_year                          = 2022, 2022, 2022,\n start_month                         = 01,   01,  01,\n start_day                           = 01,   01,  01,\n start_hour                          = 00,   00,  00,\n end_year                            = 2022, 2022, 2022,\n end_month                           = 01,   01,  01, \n end_day                             = 03,   03,  03,\n end_hour                            = 18,   18,  18,\n interval_seconds                    = 21600,\n input_from_file                     = .true.,.true.,.true.,\n history_interval                    = 60,  60, 60,\n frames_per_outfile                  = 1000, 1000, 1000,\n restart                             = .false.,\n restart_interval                    = 7200,\n io_form_history                     = 2\n io_form_restart                     = 2\n io_form_input                       = 2\n io_form_boundary                    = 2\n /\n\n &domains\n time_step                           = 90,\n time_step_fract_num                 = 0,\n time_step_fract_den                 = 1,\n max_dom                             = 3,\n e_we                                = 33,    40,  46,\n e_sn                                = 33,    40,  46,\n e_vert                              = 44,    44,  44,\n dzstretch_s                         = 1.1\n p_top_requested                     = 5000,\n use_surface                         = .false.,\n sfcp_to_sfcp                        = .true.,\n num_metgrid_levels                  = 34,                ! 34 = GFS, 38 = ERA5\n num_metgrid_soil_levels             = 4,\n dx                                  = 18000,\n dy                                  = 18000,\n grid_id                             = 1,     2,   3,\n parent_id                           = 1,     1,   1,\n i_parent_start                      = 1,     11, 15,\n j_parent_start                      = 1,     11, 15,\n parent_grid_ratio                   = 1,     3,   9,\n parent_time_step_ratio              = 1,     3,   9,\n feedback                            = 1,\n smooth_option                       = 0\n /\n\n &physics\n physics_suite                       = 'TROPICAL'\n mp_physics                          = -1,    -1,  -1,\n cu_physics                          = -1,     0,   0,\n ra_lw_physics                       = -1,    -1,  -1,\n ra_sw_physics                       = -1,    -1,  -1,\n bl_pbl_physics                      = -1,    -1,  -1,\n sf_sfclay_physics                   = -1,    -1,  -1,\n sf_surface_physics                  = -1,    -1,  -1,\n radt                                = 18,    18,  18,\n bldt                                = 0,     0,   0,\n cudt                                = 0,     0,   0,\n icloud                              = 1,\n num_land_cat                        = 21,\n sf_urban_physics                    = 0,     0,   0,\n fractional_seaice                   = 1,\n /\n\n &fdda\n /\n\n &dynamics\n hybrid_opt                          = 2, \n w_damping                           = 0,\n diff_opt                            = 2,      2,   2,\n km_opt                              = 4,      4,   4,\n diff_6th_opt                        = 0,      0,   0,\n diff_6th_factor                     = 0.12,   0.12, 0.12,\n base_temp                           = 290.\n damp_opt                            = 3,\n zdamp                               = 5000.,  5000., 5000.,\n dampcoef                            = 0.2,    0.2,     0.2,\n khdif                               = 0,      0,    0,\n kvdif                               = 0,      0,    0,\n non_hydrostatic                     = .true., .true., .true.,\n moist_adv_opt                       = 1,      1,    1,\n scalar_adv_opt                      = 1,      1,    1,\n gwd_opt                             = 1,      0,    0,\n /\n\n &bdy_control\n spec_bdy_width                      = 5,\n specified                           = .true.\n /\n\n &grib2\n /\n\n &namelist_quilt\n nio_tasks_per_group = 0,\n nio_groups = 1,\n /\n\n\n2.4.2.2 Menjalankan program real.exe dan wrf.exe\nProgram real.exe mengeluarkan file-file dalam format .nc, yaitu wrfbdy_d01 dan wrfinput_&lt;domain&gt;. Perintah menjalankan program ini adalah sebagai berikut.\n./real.exe\nUntuk melihat respon dari program ini, Anda dapat melihat file rsl.errror.0000 dengan perintah\ntail rsl.error.0000 -n 1\nJika respon yang diberikan terdapat kalimat real_em: SUCCESS COMPLETE REAL_EM INIT, Anda bisa melanjutkan ke tahapan wrf.exe.\n./wrf.exe\nSimulasi WRF dari program wrf.exe telah berhasil selesai apabila terdapat kalimat wrf: SUCCESS COMPLETE WRF pada baris terakhir rsl.error.0000 dan terdapat file wrfout_d0*. Untuk simulasi ini, terdapat 3 file wrfout_d0*: wrfout_d01_2022-01-01_00:00:00, wrfout_d02_2022-01-01_00:00:00, dan wrfout_d03_2022-01-01_00:00:00. Sejatinya, file-file tersebut berformat *.nc walaupun tidak tertera pada nama file. File wrfout_d0* memiliki interval waktu per 1 jam, dari pukul 00:00 UTC 1 Januari - 18:00 UTC 3 Januari 2022. Langkah selanjutnya, Anda dapat menganalisis luaran WRF dengan aplikasi apapun yang Anda bisa, selama mendukung format *.nc. Hanya saja, Anda perlu mengubah bentuk dan nama variabel WRF untuk disesuaikan dengan CF-Convention dengan program NCL yang telah disediakan di https://sundowner.colorado.edu/wrfout_to_cf/wrfout_to_cf.ncl.\nPengguna Docker di MacOS M1/M2 dapat menyalin file wrfout_* ke direktori lokal dengan perintah sebagai berikut.\ndocker cp &lt;nama-container&gt;:$HOME/WRF-Model/WRF/test/em_real/wrfout_* ."
  },
  {
    "objectID": "praktikum-1.html#visualisasi-luaran-wrf",
    "href": "praktikum-1.html#visualisasi-luaran-wrf",
    "title": "2  Dynamical Downscaling: Model Weather Research Forecasting (WRF)",
    "section": "2.5 Visualisasi Luaran WRF",
    "text": "2.5 Visualisasi Luaran WRF\nTerdapat 3 file luaran WRF yang telah Anda jalankan dengan masing-masing memiliki resolusi spasial yang berbeda, yaitu 18 km, 6 km, dan 2 km dengan pemilihan lokasi titik tengah longitude dan latitude di Kota Surabaya. Selanjutnya, Anda dapat melihat hasil dari simulasi tersebut dengan berbagai macam perangkat lunak. Pada modul ini, kami menampilkan hasil simulasi dengan menggunakan aplikasi NCL, QGIS, Python, R, dan Julia.\n\n2.5.1 Python\nUntuk mengetikkan kode Python. Anda dapat menggunakan kode editor Jupyter Notebook atau aplikasi lainnya, seperti Visual Studio Code, Notepad++, atau Atom. Untuk langkah-langkah di bawah ini, kami lebih menjelaskan cara penulisan kode Python pada Jupyter Notebook. Kode editor ini dapat digunakan pada aplikasi Browser default Anda, misalnya Google Chrome, Safari, atau Microsoft Edge. Kami menyarankan Anda untuk menggunakan Jupyter Notebook agar hasil kode langsung bisa ditampilkan sehingga respons dari setiap sel dapat diketahui/dicetak secara langsung. Ikuti langkah-langkah berikut ini untuk membuka Jupyter Notebook.\n\nBukalah terminal Bash Anda. Saat ini, Anda berada di direktori $HOME atau ~.\nBukalah direktori WRF-Model dengan mengetik perintah\ncd WRF-Model\nAktifkan terlebih dahulu Environment ncl dengan perintah conda activate ncl.\nKetikkan perintah berikut ini untuk memulai pengetikan kode Python. Browser default Anda akan terbuka dengan menampilkan kode editor Jupyter Notebook Gambar 2.12\njupyter notebook\n\n\n\n\nGambar 2.12: Tampilan Jupyter Notebook\n\n\n\nKlik New dan pilih Python 3 (ipykernel). Tampilan awal Jupyter Notebook seperti pada Gambar 2.13\n\n\n\n\nGambar 2.13: Tampilan awal Jupyter Notebook\n\n\n\nAnda dapat langsung mendapatkan hasil dari kode yang ditulis pada sel (lihat In [1]) (Gambar 2.14)\n\n\n\n\nGambar 2.14: Tampilan interaktif Jupyter Notebook\n\n\nUntuk pengolahan data WRF di Python, kami menggunakan wrf-python (Ladwig 2017). Paket ini dikembangkan oleh NCAR yang dikhususkan untuk Post-Processing luaran WRF, mendukung pembacaan file, perhitungan interpolasi, serta visualisasi WRF. Perhatikan langkah-langkah berikut cara penggunaannya mulai dari pembacaan file hingga pembuatan grafik.\n\nImpor paket\n\nfrom netCDF4 import Dataset\nimport wrf\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as crs\n\nBuka salah satu file wrfout_d0*, misalnya wrfout_d03_2022-01-01_00:00:00 dan cetak variabel tersebut, misalkan variabel T2 (Air Temperature at 2m: suhu udara 2 meter dari permukaan tanah). Isinya adalah beberapa metadata. Anda dapat mengetahui variabel-variabel di dalamnya dengan menambahkan metode .variables. Anda dapat melihat penjelasan variabel-variabel pada panduan pengguna WRF-ARW.\n# Lokasi folder luaran WRF\nwrf_path = '/home/absen/WRF-Model/WRF/test/em_real'\n# Membuka file wrfout\nwrf_d03 = Dataset(f\"{wrf_path}/wrfout_d03_2022-01-01_00:00:00\")\n# Melihat variabel\nwrf_d03.variables\nAnda dapat mengambil variabel dengan fungsi wrf.getvar() dengan menyertakan argumen dari nama variabel WRF. Untuk mengambil T2, gunakan perintah di bawah ini. Perhatikan hasil yang diperoleh merupakan tipe xarray.DataArray dan metode wrf.ALL_TIMES pada argumen timeidx berguna untuk mengambil seluruh waktu, mulai dari awal hingga akhir simulasi. Anda dapat mengambil salah satu waktu dengan mencantumkan angka bulat (mis. 0, 1, 2, …).\nwrf_t2 = wrf.getvar(wrf_d03, \"T2\", timeidx=wrf.ALL_TIMES)\nUntuk mendapatkan nilai koordinat latitude dan longitude dari variabel T2, Anda dapat memakai fungsi wrf.latlon_coords(). Pastikan dalam satu baris terdapat 2 variabel.\nlats, lons = wrf.latlon_coords(wrf_t2)\nUntuk mendapatkan waktu, Anda dapat memanggil Coordinates Time yang telah tersedia di dalam wrf_t2.\nwrf_time = wrf_t2.Time\nAnda juga dapat mengekstrak beberapa variabel yang tidak tersedia di dalam WRF, tentunya terbatas, seperti resultan kecepatan angin (wspd), arah angin (wdir), Convective Available Potential Energy (CAPE; cape3d_only/mcape), atau kelembapan relatif (rh2). Anda dapat membaca lebih lanjut di https://wrf-python.readthedocs.io/en/latest/diagnostics.html.\nVariabel curah hujan tidak ada di dalam WRF. Anda harus mengekstrak dan menjumlahkan variabel RAINC (Accumulated Total Cumulus Precipitation) dan RAINNC (Accumulated Total Grid Scale Cumulus Precipitation), maka diperoleh akumulasi curah hujan dari awal sampai akhir waktu simulasi. Anda perlu mengurangi curah hujan dari waktu ke \\(t\\) dengan \\(t-1\\) dengan memanfaatkan program perulangan (looping).\n# Ekstrak RAINC dan RAINNC\nrainc  = wrf.getvar(wrf_d03, \"RAINC\" , timeidx = wrf.ALL_TIMES)\nrainnc = wrf.getvar(wrf_d03, \"RAINNC\", timeidx = wrf.ALL_TIMES)\n\n# Menghitung Curah hujan akumulasi\nrain = rainc + rainnc\nrain_diff = rain.copy() # Metode .copy() agar var rain tidak ikut terubah\n\n# Lakukan perulangan\nlength = len(wrf_time.values)\nfor i in range(1, length):\n   rain_diff[i, :, :] = rain[i, :, :] - rain[i-1, :, :]\n\n# Copy Attribute (dari RAINC atau RAINNC)\nrain_diff.attrs = rainc.attrs\n# Tambahkan deskripsi\nrain_diff.attrs[\"description\"] = \"Total Rainfall\"\n# Menghapus variabel rain untuk mengoptimalkan memori\ndel rain\n\nSetelah berhasil mengekstrak variabel dari langkah sebelumnya, langkah-langkah berikut ini adalah pembuatan grafik spasial dari variabel T2. Untuk membuatnya, Anda membutuhkan tambahan package matplotlib dan cartopy.\n\nAnda telah mendefinisikan lokasi (variabel lats dan lons) pada langkah sebelumnya. Kedua variabel tersebut digunakan dalam membuat grafik spasial.\nVariabel suhu udara yang telah diekstrak pada langkah sebelumnya memiliki waktu dari awal hingga akhir simulasi. Anda hanya dapat memilih salah satu waktu dalam 1 grafik. Anda juga dapat membuat grafik untuk masing-masing waktu dalam satu grafik dalam bentuk panel plot. Untuk membuat grafik pada waktu tertentu, Anda perlu memilih waktu dan mengetahui letak indeksnya.\ntime     = \"2022-01-02 13:00:00\"\ntime     = np.array([time], dtype='datetime64[ns]')\ntime_idx = np.where(wrf_time.values == time)[0]\ntime_idx = int(time_idx)\nSebagai contoh skrip di bawah ini untuk membuat grafik spasial hanya satu waktu.\n# Mengambil informasi sistem proyeksi peta (dalam data ini adalah mercator)\ncart_proj = wrf.get_cartopy(wrf_t2, timeidx=time_idx)\n\n# Membuat dan mengatur ukuran grafik\nfig = plt.figure(figsize=(12, 10))\n# Mengatur sistem proyeksi sesuai metadata WRF\nax = plt.axes(projection=cart_proj)\n\n# Menambahkan garis pantai. Sumber data: www.naturalearthdata.com\nax.coastlines(linewidth=0.8)\n\n# Menambahkan garis lintang dan bujur\ngl = ax.gridlines(draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle='--')\ngl.top_labels = False   # Menghilangkan label bujur di atas\ngl.right_labels = False # Menghilangkan label lintang di kanan\n\n# Mengatur nilai untuk skala legenda  \nlvl = np.arange(290, 304, 2)\n\n# Menambahkan garis kontur terisi\nplt.contourf(lons, lats, wrf_t2[time_idx, :, :],\n            levels=lvl,\n            transform=crs.PlateCarree(),\n            cmap='viridis')\n\n# Menambahkan legenda warna\nplt.colorbar(ax=ax, shrink=0.7)\n\n# Menampilkan grafik\nplt.show()\n\n\n\n\nGambar 2.15: Grafik suhu udara 2-meter di atas permukaan tanah pada 2022-01-02 13:00:00 UTC\n\n\nSelain spasial, Anda dapat pula menampilkan grafik seri waktu untuk titik koordinat atau rata-rata grid tertentu.\n\nTentukan titik koordinat yang akan dibuat grafik seri waktu\nlats_sel = -7.271372797667375\nlons_sel = 112.73417496409039\nUntuk menentukan indeks dari titik koordinat yang telah didefinisikan tersebut, gunakan fungsi wrf.ll_to_xy(). Nilai yang dikeluarkan adalah indeks dari lokasi terdekat.\nlatlon_idx = wrf.ll_to_xy(wrf_d03, lats_sel, lons_sel)\nwrf_t2_sel = wrf_t2[:, latlon_idx[1], latlon_idx[0]]\nLakukan plot seri waktu\n# Mengatur ukuran grafik\nfig = plt.figure(figsize=(12, 5))\nax  = plt.axes()\n\n# Plot -&gt; x: waktu, y: suhu udara (K)\nax.plot(wrf_time, wrf_t2_sel.values)\n\n# Mengatur label dan judul \nax.set_xlabel('Waktu')\nax.set_ylabel('Suhu udara 2m (K)')\nax.set_title(f'Suhu udara di {lats_sel}$^\\circ$, {lons_sel}$^\\circ$')\n\n# Tampilkan grafik\nplt.show()\n\n\n\n\nGrafik seri waktu suhu udara 2-meter di atas permukaan tanah\n\n\n\n\n2.5.2 Python (tanpa wrf-python)\nAnda juga dapat mengolah data luaran WRF tanpa memakai wrf-python. Anda bisa menggunakan modul xarray untuk membaca dan memanipulasi data. Perlu Anda ketahui bahwa data koordinat (latitude, longitude, dan waktu) dari luaran WRF akan terlihat berbeda karena belum menyesuaikan CF-Conventions. Oleh sebab itu, Anda bisa mengkonversi data WRF menjadi format CF-Conventions dengan NCL lalu dibaca dengan mengikuti langkah-langkah di bawah ini. Beberapa langkah di bawah ini, kami menjelaskan cara-cara teknik pembacaan data WRF tanpa mengikuti CF-Conventions.\n\nImpor paket\n\nimport xarray as xr\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as crs\n\nBuka salah satu file wrfout_d0*, misalnya wrfout_d03_2022-01-01_00:00:00 dan cetak variabel tersebut, misalkan variabel T2 (Air Temperature at 2m: suhu udara 2 meter dari permukaan tanah). Untuk melihat semua variabel, ketik saja nama variabel Python yang telah didefinisikan.\n# Lokasi folder luaran WRF\nwrf_path = '/home/absen/WRF-Model/WRF/test/em_real'\n# Membuka file wrfout\nwrf_d03 = xr.open_dataset(f\"{wrf_path}/wrfout_d03_2022-01-01_00:00:00\")\n# Mencetak isi semua variabel\nwrf_d03\n# Mengambil variabel\nwrf_t2m = wrf_d03['T2']\nPada langkah sebelumnya, Anda bisa langsung melakukan pembuatan grafik spasial\ntime     = \"2022-01-02 13:00:00\"\ntime     = np.array([time], dtype='datetime64[ns]')\ntime_idx = np.where(wrf_tme == time)[0]\ntime_idx = int(time_idx)\nwrf_t2m[time_idx, :, :].plot.contourf()\nAkan tetapi, informasi koordinat spasial seperti latitude dan longitude tidak sesuai, yang ditampilkan hanyalah indeks lokasi (0, 1, 2, …). Anda perlu memodifikasi wrf_t2m dengan cara memodifikasi informasi koordinat dengan mengambil variabel lokasi dan waktu di dalam file wrfout_d0*. Untuk latitude dan longitude, Anda bisa mengambil variabel XLAT dan XLONG. Variabel waktu (XTIME) di dalam informasi coordinates tidak perlu dimodifikasi. Berikut ini adalah contoh kode untuk memodifikasi informasi koordinat.\n # Mengambil variabel XLAT dan XLONG\n wrf_lat = wrf_d03['XLAT'][0, :, 0].values\n wrf_lon = wrf_d03['XLONG'][0, 0, :].values\n # Mengambil variabel XTIME\n wrf_tme = wrf_d03['XTIME'].values\n # Membuat DataArray baru dengan informasi koordinat yang telah dimodifikasi\n wrf_t2m_new = xr.DataArray(wrf_t2m.values,\n                        coords = {'time': wrf_tme,\n                                  'lat': wrf_lat, \n                                  'lon': wrf_lon},\n                         dims = ['time', 'lat', 'lon'])\nTerakhir, Anda bisa melakukan pembuatan grafik spasial dengan memanggil variabel wrf_t2m_new yang telah dimodifikasi informasi koordinatnya. Tampilan grafik sama seperti Gambar 2.15.\n# Membuat dan mengatur ukuran grafik\nfig = plt.figure(figsize=(10, 7))\n# Mengatur sistem proyeksi peta\nax = plt.axes(projection=crs.PlateCarree())\n\n# Menambahkan garis pantai. Sumber data: www.naturalearthdata.com\nax.coastlines(linewidth=0.8)\n\n# Menambahkan garis lintang dan bujur\ngl = ax.gridlines(draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle='--')\ngl.top_labels = False   # Menghilangkan label bujur di atas\ngl.right_labels = False # Menghilangkan label lintang di kanan\n\n# Mengatur nilai untuk skala legenda  \nlvl = np.arange(290, 304, 2)\n\n# Menambahkan garis kontur terisi\nplt.contourf(wrf_lon, wrf_lat, wrf_t2m_new[time_idx, :, :],\n            levels=lvl,\n            cmap='viridis')\n\n# Menambahkan legenda warna\nplt.colorbar(ax=ax, shrink=0.7)\n\n# Menampilkan grafik\nplt.show()\n\n\n\n2.5.3 R\nAnda dapat menggunakan RStudio untuk menuliskan skrip R. Untuk mengolah data WRF di R, Anda perlu memasang package ncdf4 dan raster terlebih dahulu. Untuk kebutuhan plot seri waktu, kami menggunakan package tidyverse.\n\nSebelum memulai pengetikan kode R, buatlah file skrip R dengan memilih menu File &gt; New File &gt; R Script.\nDi console R pada RStudio, gunakan perintah berikut untuk memasang ncdf4 dan raster.\ninstall.packages(c('ncdf4', 'raster'))\nAnda juga dapat menggunakan menu pada RStudio: Tools &gt; Install Packaages. Kemudian, ketik “ncdf4, raster” (tanpa tanda petik) pada bagian Packages (separate multiple with space or comma). Setelah itu, klik Install.\nKami telah menyediakan fungsi skrip R untuk membuka file luaran WRF. Pada teks editor di RStudio, masukkan perintah berikut untuk mengimpor package ncdf4 dan raster beserta skrip wrf-raster.R. Fungsi wrf-raster.R dapat diunduh di https://github.com/agungbaruna/modul-pemodelan-iklim/blob/main/scripts/wrf-raster.R. Letakkan fungsi ini di dalam folder Project RStudio Anda.\nlibrary(ncdf4)\nlibrary(raster)\nlibrary(tidyverse)\nsource('wrf-raster.R')\nAnda dapat menjalankan ketiga baris kode tersebut dengan memblok seluruh baris atau arahkan kursor pada akhir kode kemudian tekan tombol CTRL + ENTER.\nSaat Anda menjalankan source('wrf-raster.R'), muncul Functions dengan nama wrf.raster pada jendela Environment di RStudio (letak jendela di sebelah kanan atas).\nUntuk menggunakan fungsi wrf.raster(), Anda hanya membutuhkan argumen wrf.file (nama folder wrfout_*) dan var.name (nama variabel di dalam wrfout_*). Nilai kembalian setelah menjalankan fungsi ini berbentuk RasterBrick. Argumen nlev dapat dicantumkan dengan angka bilangan bulat (1, 2, 3, …) khusus untuk variabel yang memiliki variasi terhadap ketinggian dan kedalaman, seperti suhu udara atau suhu tanah. Variabel lain yang tidak tercantum seperti curah hujan, sudah tersedia di dalam fungsi ini (var.name = rain).\nSebagai contoh mengambil variabel curah hujan.\nrain &lt;- wrf.raster(wrf.file = '/home/absen/WRF-Model/WRF/test/em_real/wrfout_d01_2022-01-01_00:00:00', var.name = 'rain')\nrain\nclass      : RasterBrick\ndimensions : 32, 32, 1024, 67  (nrow, ncol, ncell, nlayers)\nresolution : 0.1581326, 0.1567945  (x, y)\nextent     : 110.2099, 115.2701, -9.821663, -4.804237  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs\nsource     : memory\nnames      :   layer.1,   layer.2,   layer.3,   layer.4,   layer.5,   layer.6,  ...\nmin values :         0,         0,         0,         0,         0,         0,  ...\nmax values :  0.000000,  2.944275,  2.439148,  6.013021, 14.848666, 47.531946,  ...\ntime       : 2022-01-01 00:00:00, 2022-01-03 18:00:00 (min, max)\nPada respons melalui console R, terdapat berbagai informasi seperti dimensions, resolution, crs, serta time. Anda dapat mudah memahami isi dari file wrfout_d01* tersebut.\nAnda bisa langsung membuat grafik spasial dengan perintah 1 baris ini dan ditampilkan pada Gambar 2.16. Cukup sederhana.\nplot(rain)\n\n\n\n\nGambar 2.16: Plot curah hujan per 1 jam dari wrfout_d01*\n\n\n\nUntuk membuat grafik seri waktu pada lokasi tertentu, Anda dapat menggunakan fungsi extract() dan plot()\n# Waktu\ntime_sel &lt;- getZ(rain)\n\n# Lokasi\nlats_sel &lt;- -7.271372797667375\nlons_sel &lt;- 112.73417496409039\n\n# Ekstrak nilai curah hujan berdasarkan lokasi\nrain_sel &lt;- extract(rain, data.frame(x = lons_sel, y = lats_sel))\n\n# Plot grafik seri waktu\nggplot() +\n   geom_line(aes(x = time_sel, y = rain_sel[1,])) +\n   scale_x_datetime(\"Waktu (UTC)\", date_labels = \"%Y-%m-%d %H:%M\") +\n   scale_y_continuous(\"Curah Hujan (mm/jam)\")\n\n\n\n\n2.5.4 NCL\nNCAR telah menyediakan contoh skrip pengolahan data WRF dengan NCL. Anda dapat mengakses lebih banyak di https://www.ncl.ucar.edu/Applications/wrf.shtml. File netcdf luaran WRF pada dasarnya berbeda dengan file netcdf pada umumnya karena tidak mengikuti pedoman Climate and Forecast Convention. Alhasil, mengolah data WRF menggunakan aplikasi lain seperti ArcMap atau Matlab cukup rumit. Jika Anda ingin cukup mudah mengolahnya dengan aplikasi lainnya, skrip NCL untuk mengubah WRF menjadi CF-Convention dibuat oleh Mark Seefeldt dan telah tersedia di https://sundowner.colorado.edu/wrfout_to_cf/wrfout_to_cf.ncl. Berikut ini adalah cara penggunakan skrip wrfout_to_cf.ncl.\n\nAktifkan terlebih dahulu environment ncl pada terminal. Tulisan (base) menjadi (ncl) setelah perintah berhasil dipanggil.\nconda activate ncl\nAnda hanya perlu memasukkan variabel dir_in (lokasi folder wrfout), dir_out (lokasi folder wrfout setelah dikonversi), file_in (nama file wrfout), dan file_out (nama file wrfout setelah dikonversi).\nMasukkan perintah berikut.\nncl 'dir_in=\"/home/absen/WRF-Model/WRF/test/em_real/\"' 'file_in=\"wrfout_d01_2022-01-01_00:00:00\"' 'file_out=\"wrfout_cf_d01_2022-01-01_00:00:00.nc\"' wrfout_to_cf.ncl\nAnda dapat mengolah data luaran WRF setelah dikonversi menjadi CF-Convention pada aplikasi apapun dengan mudah. Hanya saja, Anda perlu memperhatikan perubahan nama variabel dan sesuaikan dengan data WRF asli.\n\nSelain mengubah menjadi CF-Convention, Anda dapat langsung menerapkan skrip NCL untuk analisis maupun visualisasi. Sebagai contoh skrip berikut ini untuk menampilkan suhu udara dekat permukaan dari luaran wrfout_d01*. Perlu diperhatikan bahwa simbol ; adalah komentar di dalam NCL. Anda dapat mengganti format file dari luaran skrip ini (mis. png, pdf, atau x11).\n;---Read file\nfpath    = \"/home/absen/WRF-Model/WRF/test/em_real/\"\nfilename = \"wrfout_d01_2022-01-01_00:00:00\"\na        = addfile(fpath+filename, \"r\")\n\n;---Get CEN_LAT and CEN_LON from WRF metadata (in global attributes)\ncen_lat = a@CEN_LAT\ncen_lon = a@CEN_LON\n\n;---Select time index\nnt = 30\n\n;---Read temperature at first time step\ntc = wrf_user_getvar(a, \"tc\", nt)\n\n;---Open worksheet\nwks = gsn_open_wks(\"png\", \"wrf_nogsn\") ; Format file luaran grafik, contoh png\n\n;---Set up resource list\nres                      = True\nres@gsnDraw              = False\nres@gsnFrame             = False\nres@tfDoNDCOverlay       = True\n\n;---Plotting options for air temperature\nopts_r                      = res\n\nopts_r@cnFillOn             = True\nopts_r@cnLevelSelectionMode = \"ExplicitLevels\"\nopts_r@cnLevels             = (/ 20, 22, 24, 26, 28, 30, 32 /)\nopts_r@cnSmoothingOn        = True\nopts_r@cnSmoothingDistanceF = .005\n\n;---Option for plt_res\nplt_res = res\n\n;---Option for plt_res\nmap_res = res\nmap_res@mpDataBaseVersion           = \"HighRes\"            ; Jika memilih \"HighRes\", Anda harus mengunduh semua file di  \nmap_res@mpDataResolution            = \"FinestResolution\"   ; https://www.io-warnemuende.de/rangs-en.html\nmap_res@mpCenterLatF                = cen_lat              ; dan letakkan di folder $NCARG_ROOT/lib/ncarg/database/rangs\nmap_res@mpCenterLonF                = cen_lon\nmap_res@mpGeophysicalLineColor      = \"black\"\nmap_res@mpGeophysicalLineThicknessF = 2.0\nmap_res@mpGridSpacingF              = 1.0\nmap_res@mpGridLineColor             = \"black\"\n\n;---Plot\ncontour_tot = wrf_contour(a, wks, tc(0,:,:), opts_r)\nplot = wrf_map_overlays(a, wks, (/contour_tot/), plt_res, map_res)\n\n\n\nPlot suhu udara dekat permukaan pada 2022-01-02 06:00:00 UTC\n\n\n\n\n2.5.5 QGIS\nAplikasi QGIS dapat juga digunakan untuk mengolah data WRF. Untuk memudahkan pengolahan data WRF, Anda perlu mengubah data WRF menjadi CF-Convention dengan skrip NCL sebelumnya. Setelah itu, Anda dapat mengimpor data WRF yang telah terkonversi dalam format NetCDF Classic ke QGIS. Berikut ini adalah langkah-langkahnya.\n\nPada menu QGIS, pilih Layer &gt; Add Layer &gt; Add Raster Layer (CTRL + SHIFT + R).\nPada bagian Source, klik ikon ... dan pilih file wrfout_* yang telah dikonversi menjadi CF-Convention.\n\nPilih variabel yang ingin Anda tampilkan. Misalnya, Anda dapat memilih T_2m untuk menampilkan suhu udara pada ketinggian 2 meter. Klik Add Layers, kemudian klik Add.\nKlik kanan pada raster yang telah diimpor dan pilih Properties. Pada Band Rendering di bagian Render type, pilih Singleband Gray. Pada bagian Gray band, terdapat pilihan nomor Band yang berisikan waktu.\n\nNilai maksimum dan minimum suhu udara dapat terlihat di bawah layer.\nSetelah berhasil mengimpor, data raster dari WRF belum terproyeksi ke koordinat. Default sistem proyeksi pada QGIS kami adalah EPSG:4326 - WGS 84. Untuk mengubah sistem proyeksi, klik menu Raster &gt; Projections &gt; Warp (Reproject). Bagian Input layer diisi dengan raster yang akan diubah sistem proyeksinya dan Target CRS diisi dengan EPSG:4326 - WGS 84. Kemudian, klik Run.\n\nLayer raster baru akan muncul dengan nama Reprojected. Klik kanan pada raster tersebut dan pilih Zoom to Layer(s)\nAgar lebih meyakinkan, Anda dapat mengimpor file vector dari batas wilayah Indonesia. Untuk data ini, bisa Anda unduh di gadm.org. Pada contoh ini, kami menggunakan file *.json. Untuk mengimpornya, klik menu Layer &gt; Add Layer &gt; Add Vector Layer (CTRL + SHIFT + V). Pada bagian Source, klik ikon ... dan pilih file gadm41_IDN_1.json. Klik Add Layers, kemudian klik Add.\n\n\n\n\n2.5.6 Julia\nSelain R dan Python, bahasa pemrograman Julia juga dapat digunakan untuk mengolah data WRF. Hanya saja, package khusus untuk WRF masih belum tersedia. Julia dapat digunakan di sistem operasi apa saja. Untuk pengguna Windows 10/11, Anda bisa menggunakan WSL atau terminal Windows langsung. Untuk membaca data netcdf dari WRF, algoritma yang kami berikan cukup memerlukan logika sehingga tidak semudah mengolahnya seperti di R. Anda dapat menggunakan package NCDatasets.jl, sedangkan untuk membuat grafik menggunakan Plots.jl. Berikut ini adalah langkah-langkahnya.\n\nBuka terminal interaktif Julia dengan mengetik julia.exe pada Command Prompt/PowerShell atau carilah program Julia pada Start Menu.\nBuka Jupyter Notebook pada terminal interaktif Julia dengan perintah berikut ini.\nusing IJulia\nnotebook()\nAktifkan package NCDatasets.jl dan Plots.jl.\nusing NCDatasets\nusing Plots\nAnda dapat menggunakan fungsi ncread() untuk membaca data WRF sekaligus menentukan variabel yang ingin diimpor. Berikut ini adalah contoh untuk mengimpor data suhu udara pada ketinggian 2 meter.\nwrf_path = \"C:\\\\Users\\\\taats\\\\Desktop\\\\\";\nwrf_file = joinpath(wrf_path, \"wrfout_d01_2022-01-01_00\");\nds = NCDataset(wrf_file, \"r\");\nt2 = ds[\"T2\"]\nT2 (32 × 32 × 67)\n  Datatype:    Float32\n  Dimensions:  west_east × south_north × Time\n  Attributes:\n  FieldType            = 104\n  MemoryOrder          = XY \n  description          = TEMP at 2 M\n  units                = K\n  stagger              = \n  coordinates          = XLONG XLAT XTIME\n\n\n\n\n\n\n\nCatatan\n\n\n\nPerhatikan tanda ; pada akhir baris kode. Tanda ini digunakan untuk menghilangkan respons dari kode tersebut. Cara ini sama seperti sintaks pada Matlab.\n\n\nDimensi pada variabel t2 bervariasi terhadap longitude (west_east), latitude (south_north), dan waktu (Time) secara berturut-turut. Cara membaca dimensi ini sama seperti pada package ncdf4 di R. Hanya saja, ini sudah didefinisikan di dalam skrip wrf-raster.R.\n\nSebelum menampilkan data, Anda perlu mengambil lokasi (latitude dan longitude).\nlat = ds[\"XLAT\"][1, :, 1];\nlon = ds[\"XLONG\"][:, 1, 1];\nAnda dapat menampilkan grafik spasial untuk 1 waktu dengan package Plots.jl dengan fungsi heatmap().\nnt = 1 # Indeks waktu = \"2022-01-01 00:00:00\"\nheatmap(lon, lat, transpose(t2[:, :, nt]))\nylabel!(\"latitude\")  # Menambahkan label sumbu y \nxlabel!(\"longitude\") # Menambahkan label sumbu x\nNilai pada setiap baris dari t2 bervariasi terhadap longitude, sedangkan pada kolom bervariasi terhadap latitude. Untuk menampilkan grafik dengan koordinat yang benar, Anda perlu membalikkan (baris ke kolom, dan sebaliknya) pada matriks t2 dengan fungsi transpose().\n\nSelain divisualisasikan dalam bentuk grid/raster, Anda juga dapat menampilkan dalam bentuk kontur terisi dengan fungsi contourf() dari package Plots.jl.\nnt = 10 # Indeks waktu = \"2022-01-01 09:00:00\"\ncontourf(lon, lat, transpose(t2[:, :, nt]))\nylabel!(\"latitude\")  # Menambahkan label sumbu y \nxlabel!(\"longitude\") # Menambahkan label sumbu x\n\nUntuk grafik seri waktu, Anda dapat menggunakan fungsi plot() dari package Plots.jl. Berikut ini adalah contoh untuk menampilkan grafik seri waktu suhu udara pada ketinggian 2 meter.\nusing Dates\n\n# Mengambil variabel waktu\ntime = ds[\"XTIME\"];\nticks = Dates.format.(time, \"yyyy-mm-dd HH:MM\");\n\n# Pemilihan lokasi\nlats_sel =  -7.27;\nlons_sel = 112.73;\n\nlat_idx = findall(y -&gt; (y &gt; lats_sel - 0.1) && (y &lt; lats_sel + 0.1), lat);\nlon_idx = findall(x -&gt; (x &gt; lons_sel - 0.1) && (x &lt; lons_sel + 0.1), lon);\n\nlons = lon[lon_idx];\nlats = lat[lat_idx];\n\n# Membuat grafik seri waktu\nplot(ticks, t2[lon_idx[1], lat_idx[1], 1:length(time)], \n     labels=\"$(lons[1]); $(lats[1])\", xrotation=45)\nplot!(ticks, t2[lon_idx[2], lat_idx[1], 1:length(time)],\n     labels=\"$(lons[2]); $(lats[1])\")\nylabel!(\"Suhu udara 2m (°C)\") # Menambahkan label sumbu y \nxlabel!(\"Waktu (per 1 jam)\")  # Menambahkan label sumbu x\n\n\n\n\n\n\nBao J, Chow FK, Lundquist KA. 2018. Large-eddy simulation over complex terrain using an improved immersed boundary method in the weather research and forecasting model. Monthly Weather Review. 146(9):2781–2797.\n\n\nGlotter M, Elliott J, McInerney D, Best N, Foster I, Moyer EJ. 2014. Evaluating the utility of dynamical downscaling in agricultural impacts projections. Proceedings of the National Academy of Sciences. 111(24):8776–8781.\n\n\nGoly A, Teegavarapu RS, Mondal A. 2014. Development and evaluation of statistical downscaling models for monthly precipitation. Earth Interactions. 18(18):1–28.\n\n\nHuth R, Kyselỳ J. 2000. Constructing site-specific climate change scenarios on a monthly scale using statistical downscaling. Theoretical and Applied Climatology. 66(1):13–27.\n\n\nKim J, Chang J, Baker N, Wilks D, Gates W. 1984. The statistical problem of climate inversion: Determination of the relationship between local and large-scale climate. Monthly weather review. 112(10):2069–2077.\n\n\nLadwig W. 2017. Wrf-python version 1.3.4.doi:https://doi.org/10.5065/D6W094P1.\n\n\nPahlavan H, Zahraie B, Nasseri M, Mahdipour Varnousfaderani A. 2018. Improvement of multiple linear regression method for statistical downscaling of monthly precipitation. International journal of environmental science and technology. 15(9):1897–1912.\n\n\nPiani C, Haerter J, Coppola E. 2010. Statistical bias correction for daily precipitation in regional climate models over europe. Theoretical and Applied Climatology. 99(1-2):187–192.\n\n\nPiani C, Weedon G, Best M, Gomes S, Viterbo P, Hagemann S, Haerter J. 2010. Statistical bias correction of global simulated daily precipitation and temperature for the application of hydrological models. Journal of Hydrology. 395(3-4):199–215.\n\n\nPowers JG, Klemp JB, Skamarock WC, Davis CA, Dudhia J, Gill DO, Coen JL, Gochis DJ, Ahmadov R, Peckham SE, et al. 2017. The weather research and forecasting model: Overview, system efforts, and future directions. Bulletin of the American Meteorological Society. 98(8):1717–1737.doi:10.1175/BAMS-D-15-00308.1.\n\n\nRichardson CW. 1981. Stochastic simulation of daily precipitation, temperature, and solar radiation. Water resources research. 17(1):182–190.\n\n\nSachindra D, Huang F, Barton A, Perera B. 2014. Statistical downscaling of general circulation model outputs to precipitation—part 1: Calibration and validation. International Journal of Climatology. 34(11):3264–3281.\n\n\nSkamarock WC, Klemp JB, Dudhia J, Gill DO, Barker DM, Wang W, Powers JG. 2019. A description of the advanced research WRF version 4. National Center For Atmospheric Research Boulder Co Mesoscale; Microscale ….\n\n\nSmid M, Costa AC. 2018. Climate projections and downscaling techniques: A discussion for impact studies in urban systems. International Journal of Urban Sciences. 22(3):277–307.doi:10.1080/12265934.2017.1409132.\n\n\nSonkaew T, Cumwan S, Kanta W, Macatangay R. Finding the optimum microphysics and convective parameterization schemes for the WRF model for LPRU, thailand.\n\n\nTalbot C, Bou-Zeid E, Smith J. 2012. Nested mesoscale large-eddy simulations with WRF: Performance in real test cases. Journal of Hydrometeorology. 13(5):1421–1441.\n\n\nWilby RL, Wigley TM. 1997. Downscaling general circulation model output: A review of methods and limitations. Progress in physical geography. 21(4):530–548.\n\n\nXu H, Wang M, Wang Y, Cai W. 2018. Performance of WRF large eddy simulations in modeling the convective boundary layer over the taklimakan desert, china. Journal of Meteorological Research. 32(6):1011–1025."
  },
  {
    "objectID": "praktikum-2.html#pendahuluan",
    "href": "praktikum-2.html#pendahuluan",
    "title": "3  Model Pendugaan Radiasi Matahari",
    "section": "3.1 Pendahuluan",
    "text": "3.1 Pendahuluan\nRadiasi matahari merupakan sumber energi utama dan berperan penting dalam siklus iklim bumi. Besaran radiasi matahari yang datang kemudian mengalami proses pemantulan, pemancaran, dan penerusan baik secara langsung maupun tidak langsung ke dan dari permukaan bumi. Radiasi matahari yang datang tersebut berpengaruh terhadap pergerakan massa udara dan massa air di bumi, selanjutnya melalui proses evaporasi maupun transpirasi, uap air dilepaskan ke udara dan membentuk awan sehingga terjadi hujan.\nPengukuran radiasi matahari secara langsung masih terbilang sedikit dengan periode perekaman data historis yang pendek. Padahal pengamatan radiasi matahari sangat penting dalam menjelaskan variabilitas dan perubahan iklim. Pada pemodelan iklim yang terus berkembang untuk menjelaskan kondisi iklim di masa lalu, saat ini dan masa depan tak lepas dari input data radiasi matahari dan kondisi karbon di atmosfer. Untuk mengetahui besaran nilai penduga radiasi matahari di suatu wilayah dapat dilakukan melalui model berdasarkan data historis parameter iklim lainnya seperti curah hujan dan suhu udara. Pendekatan dapat dilakukan dengan menggunakan model empirik dan model mekanistik.\nAplikasi pengolahan data yang digunakan dalam praktikum ini adalah R dan Python (pilih salah satu). Data contoh yang digunakan adalah data cuaca di Bandara Laguardia, New York, Amerika Serikat."
  },
  {
    "objectID": "praktikum-2.html#sec-modelball",
    "href": "praktikum-2.html#sec-modelball",
    "title": "3  Model Pendugaan Radiasi Matahari",
    "section": "3.2 Model Pendugaan Ball et al. (2004)",
    "text": "3.2 Model Pendugaan Ball et al. (2004)\nBall et al. (Ball et al. 2004) membangun model empiris untuk menduga radiasi matahari di permukaan bumi dengan masukan suhu udara maksimum, suhu udara minimum, curah hujan, dan julian days. Persamaan yang digunakan berupa regresi linier berganda, yaitu\n\\[\nY = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + \\beta_3 X_3 + ... + \\beta_{12} X_{12}\n\\]\ndi mana keterangan setiap variabel bebas dapat dilihat pada tabel berikut.\n\n\nTabel 3.1: Keterangan variabel bebas dari persamaan empirik (Ball et al. 2004)\n\n\nPrediktor\nKeterangan\n\n\n\n\n\\(X_{1}\\)\nCurah hujan (mm)\n\n\n\\(X_{2}\\)\nSuhu udara maksimum (°C)\n\n\n\\(X_{3}\\)\nSuhu udara minimum (°C)\n\n\n\\(X_{4}\\)\nDay of Year\n\n\n\\(X_{5}\\)\n(Curah hujan)²\n\n\n\\(X_{6}\\)\n(Suhu udara maksimum)²\n\n\n\\(X_{7}\\)\n(Suhu udara minimum)²\n\n\n\\(X_{8}\\)\n(Day of Year)²\n\n\n\\(X_{9}\\)\nCurah hujan * Suhu udara minimum\n\n\n\\(X_{10}\\)\nSuhu udara maksimum * Suhu udara minimum\n\n\n\\(X_{11}\\)\nCurah hujan * Suhu udara maksimum\n\n\n\\(X_{12}\\)\nSuhu udara maksimum * Day of Year"
  },
  {
    "objectID": "praktikum-2.html#sec-modelhunt",
    "href": "praktikum-2.html#sec-modelhunt",
    "title": "3  Model Pendugaan Radiasi Matahari",
    "section": "3.3 Model Pendugaan Hunt et al. (1998)",
    "text": "3.3 Model Pendugaan Hunt et al. (1998)\nModel pendugaan radiasi matahari lain adalah oleh Hunt (Hunt et al. 1998), yaitu gabungan model mekanistik dan empirik dengan masukan suhu udara maksimum, suhu udara minimum, dan curah hujan. Model mekanistik digunakan untuk menduga radiasi matahari yang berada di permukaan atmosfer (radiasi ekstraterestrial, \\(S_0\\)). Model pendugaan Hunt (1998) adalah sebagai berikut.\n\\[\nR_s = a_0 S_0 (T_{max} - T_{min})^{0.5} + a_1 T_{max} + a_2 P + a_3 P^2 + a_4\n\\]\ndimana \\(R_s\\) adalah radiasi matahari harian (\\(MJ~m^{−2}~hari^{−1}\\)), \\(S_0\\) adalah radiasi matahari di puncak atmosfer (\\(MJ~m^{−2}~hari^{−1}\\)), \\(P\\) adalah curah hujan (mm), \\(T_{max}\\) adalah suhu udara maksimum (\\(^o C\\)), dan \\(T_{min}\\) adalah suhu udara minimum (\\(^o C\\)). Untuk mengestimasi nilai \\(S_0\\), Hunt menggunakan persamaan mekanistik dalam Spitters (Spitters et al. 1986), yaitu:\n\\[\nS_0 = S_{sc} \\left[ 1 + 0.033 \\cos \\left( \\frac{360~t_d}{365} \\right) \\right] sin(β)\n\\]\ndimana, \\(S_0\\) adalah irradiasi ekstra terestrial (\\(J~m^{−2} s^{−1}\\)), \\(S_{sc}\\) konstanta matahari (\\(1370~J~m^{−2} s^{−1}\\)), suku \\(cos\\) adalah jarak tahunan antara bumi dan matahari yang dinyatakan dalam derajat, \\(t_d\\) adalah julian day, dan \\(sin(β)\\) adalah sinus sudut elevasi matahari (satuan detik) yang didefinisikan pada persamaan:\n\\[\nsin(β) = 3600 \\left[ D ~ sin(λ) ~ sin(δ) + \\frac{24}{\\pi} ~ cos(λ) ~ cos(δ) ~ \\sqrt{(1 - tan^2(λ) ~ tan^2(δ))} \\right]\n\\]\ndimana, \\(λ\\) adalah letak lintang dari lokasi stasiun dan δ adalah sudut deklinasi matahari pada saat julian day dan dinyatakan dalam derajat dengan estimasi pada persamaan:\n\\[\nsin(δ) = -sin(23.45) ~ cos \\left( \\frac{360~(t_d + 10)}{365} \\right)\n\\]\ndan \\(D\\) adalah panjang hari (jam) dengan persamaan:\n\\[\nD = 12 + \\frac{24}{180} arcsin(tan(λ) ~ tan(δ))\n\\]"
  },
  {
    "objectID": "praktikum-2.html#pengolahan-data",
    "href": "praktikum-2.html#pengolahan-data",
    "title": "3  Model Pendugaan Radiasi Matahari",
    "section": "3.4 Pengolahan Data",
    "text": "3.4 Pengolahan Data\nData yang akan diolah bernama LaguardiaAirport-NYC.xlsx yang terdiri dari tiga worksheet. Worksheet ke-3 (RawData) adalah data yang akan diolah dengan berisikan 7 kolom: DOY (Day of Year, 1 sampai 365 atau 366), YEAR (tahun), PRCP (curah hujan, mm), TAVG (suhu udara rata-rata, °C), TMAX (suhu udara maksimum, °C), TMIN (suhu udara minimum, °C), dan SRAD (radiasi matahari langsung, W/m²). Data pada worksheet tersebut sudah dirapikan sehingga Anda dapat langsung mengolahnya. Periode data yang digunakan dibagi menjadi 2, yaitu untuk pembuatan dan validasi model dengan pemilihan tahun 1998-2018 dan 2019-2020, secara berturut-turut.\n\n3.4.1 R\nPackage yang digunakan dalam pengolahan data di R adalah tidyverse dan readxl. Jika Anda belum memasang package ini, gunakan perintah berikut.\ninstall.packages(c(\"tidyverse\", \"readxl\"))\nPengetikan kode R dapat dilakukan di aplikasi RStudio atau teks editor lainnya yang Anda kuasai.\n\nModel Ball et al. (2004)\n\nImpor data excel (LaguardiaAirport-NYC.xlsx) pada sheet RawData dengan perintah berikut.\ndpath &lt;- \"data/\" # Lokasi folder data\ndata &lt;- read_excel(paste0(dpath, \"LaguardiaAirport-NYC.xlsx\"), sheet = \"RawData\")\ndata\n# A tibble: 8,401 × 7\n    YEAR   DOY  PRCP  TAVG  TMAX  TMIN  SRAD\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  1998     1   0    -5    -1.1  -8.9 107.\n 2  1998     2   0     4.7  10    -0.6  82.8\n 3  1998     3   0    12    15.6   8.3  74.7\n 4  1998     4   0    11.7  17.2   6.1  78.8\n 5  1998     5   0     5.9   6.7   5    75.6\n 6  1998     6   1    10.3  15     5.6  34.3\n 7  1998     7  28.7   9.5  13.9   5    26.8\n 8  1998     8   0.8  10.3  16.1   4.4  37.5\n 9  1998     9   0    12    15     8.9  46.8\n10  1998    10   0     7.8  10     5.6  97.6\n# … with 8,391 more rows\n# ℹ Use `print(n = ...)` to see more rows\nPilih periode tahun untuk pembuatan dan validasi model dengan perintah berikut.\n# Pembuatan model\ndata_train &lt;- data %&gt;% filter(YEAR &lt;= 2018)\n\n# Validasi model\ndata_test &lt;- data %&gt;% filter(YEAR &gt;= 2019)\nLakukan perhitungan prediktor ke-5 sampai ke-12 sesuai dengan Tabel 3.1\ndata_train &lt;- data_train %&gt;%\n   mutate(\n      PRCP_sq = PRCP^2, TMAX_sq = TMAX^2, TMIN_sq = TMIN^2, DOY_sq  = DOY^2,\n      PRCP_TMAX = PRCP * TMAX, PRCP_TMIN = PRCP * TMIN,\n      TMAX_TMIN = TMAX * TMIN, TMAX_DOY  = TMAX * DOY\n   )\n\ndata_test &lt;- data_test %&gt;%\n   mutate(\n      PRCP_sq = PRCP^2, TMAX_sq = TMAX^2, TMIN_sq = TMIN^2, DOY_sq  = DOY^2,\n      PRCP_TMAX = PRCP * TMAX, PRCP_TMIN = PRCP * TMIN,\n      TMAX_TMIN = TMAX * TMIN, TMAX_DOY  = TMAX * DOY\n   )\nLakukan pembuatan model regresi linier berganda pada data data_train sesuai dengan model Ball (Tabel 3.1).\nmodel &lt;- lm(SRAD ~ PRCP + TMAX + TMIN + DOY + \n                   PRCP_sq + TMAX_sq + TMIN_sq + DOY_sq + \n                   PRCP_TMAX + PRCP_TMIN + TMAX_TMIN + TMAX_DOY, \n            data = data_train)\nsummary(model)\nCall:\nlm(formula = SRAD ~ PRCP + TMAX + TMIN + DOY + PRCP_sq + TMAX_sq +\n    TMIN_sq + DOY_sq + PRCP_TMAX + PRCP_TMIN + TMAX_TMIN + TMAX_DOY,\n    data = data_train)\n\nResiduals:\n     Min       1Q   Median       3Q      Max\n-230.598  -30.858    2.829   32.497  189.113\n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept) -4.120e+01  4.068e+00 -10.126  &lt; 2e-16 ***\nPRCP        -3.315e+00  1.933e-01 -17.151  &lt; 2e-16 ***\nTMAX         2.259e+01  8.621e-01  26.203  &lt; 2e-16 ***\nTMIN        -2.705e+01  8.212e-01 -32.945  &lt; 2e-16 ***\nDOY          1.988e+00  4.015e-02  49.508  &lt; 2e-16 ***\nPRCP_sq      2.469e-02  1.324e-03  18.649  &lt; 2e-16 ***\nTMAX_sq     -9.876e-01  4.577e-02 -21.577  &lt; 2e-16 ***\nTMIN_sq     -1.481e+00  5.217e-02 -28.386  &lt; 2e-16 ***\nDOY_sq      -5.281e-03  1.029e-04 -51.317  &lt; 2e-16 ***\nPRCP_TMAX   -1.217e-01  1.966e-02  -6.189 6.35e-10 ***\nPRCP_TMIN    1.448e-01  2.069e-02   6.998 2.82e-12 ***\nTMAX_TMIN    2.602e+00  9.450e-02  27.534  &lt; 2e-16 ***\nTMAX_DOY    -1.184e-02  7.625e-04 -15.534  &lt; 2e-16 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\nResidual standard error: 47.29 on 7657 degrees of freedom\nMultiple R-squared:  0.7423,    Adjusted R-squared:  0.7419\nF-statistic:  1838 on 12 and 7657 DF,  p-value: &lt; 2.2e-16\nBisa Anda lihat pada bagian Multiple R-squared untuk mengetahui nilai dari koefisien determinasi (R²). Semua prediktor yang digunakan untuk mengestimasi radiasi matahari signifikan (p-value \\(&lt; 0.05\\)) dengan nilai R²=74%.\nAnda dapat melakukan estimasi nilai radiasi matahari pada model yang sudah dibangun dengan menggunakan data validasi (data_test) dengan perintah berikut.\ndata_test &lt;- data_test %&gt;%\n   mutate(SRAD_pred = predict(model, data_test))\nKemudian, lakukan perhitungan koefisien determinasi (R²) dan korelasi Pearson (r) pada data_test dengan perintah berikut.\n# korelasi Pearson (r)\nr &lt;- cor(data_test$SRAD, data_test$SRAD_pred)\n\n# koefisien determinasi (R²)\nR2 &lt;- r^2\n\n# Print\nprint(r); print(R2)\n[1] 0.8508384\n[1] 0.7239259\nAtau bisa juga dengan melakukan plot antara nilai aktual dan prediksi radiasi matahari dengan menampilkan garis regresi beserta persamaan regresinya ditambah dengan nilai R² dan r (?fig-sunplotball1)\nggplot(data_test, aes(x = SRAD_pred, y = SRAD)) +\n   geom_point() +\n   geom_abline(intercept = 0, slope = 1, color = \"blue\") +\n   labs(y = \"Observasi (W/m²)\", x = \"Model (W/m²)\")\n\nJika Anda perhatikan pada ?fig-sunplotball1, nilai radiasi matahari tidak mungkin bernilai negatif dan ini umum terjadi saat menggunakan model regresi. Oleh karena itu, nilai radiasi matahari yang bernilai negatif diubah menjadi 0 (?fig-sunplotball2).\ndata_test &lt;- data_test %&gt;%\n   mutate(SRAD_pred = ifelse(SRAD_pred &lt; 0, 0, SRAD_pred))\n\nggplot(data_test, aes(x = SRAD_pred, y = SRAD)) +\n   geom_point() +\n   geom_abline(intercept = 0, slope = 1, color = \"blue\") +\n   scale_x_continuous(limits = c(0, 400), expand = c(0, 0)) +\n   scale_y_continuous(limits = c(0, 400), expand = c(0, 0)) +\n   labs(y = \"Observasi (W/m²)\", x = \"Model (W/m²)\") \n\n\n\n\nModel Hunt et al. (1998)\nLangkah-langkah pembuatan model radiasi matahari dengan menggunakan model Hunt et al. (1998) adalah sebagai berikut.\n\nImpor data Excel. Caranya sama seperti pada subbab sebelumnya.\nSebelum Anda melakukan pembuatan model regresi linier berganda, Anda harus melakukan perhitungan \\(S_0\\) terlebih dahulu. Kami menyediakan fungsi untuk menghitung nilai \\(S_0\\) seperti pada Section 3.3. Anda hanya memasukkan nilai latitude serta day of year pada fungsi ini.\nS0 &lt;- function(lat, doy){\n   # Fungsi untuk menghitung sin(delta)\n   sin_delta &lt;- -sinpi(23.45 / 180) * cospi((360 * (doy + 10) / 365) / 180)\n   asin_delt &lt;- asin(sin_delta) * 180 / pi\n\n   # sin(lat) * sin(delta)\n   s_lat_delt &lt;- sinpi(lat / 180) * sinpi(asin_delt / 180)\n\n   # cos(lat) * cos(delta)\n   c_lat_delt &lt;- cospi(lat / 180) * cospi(asin_delt / 180)\n\n   # (sin(lat) * sin(delta)) / (cos(lat) * cos(delta))\n   t_lat_delt &lt;- s_lat_delt / c_lat_delt\n\n   # Fungi perhitungan panjang hari (D)\n   D &lt;- 12 + 24/180 * asin(t_lat_delt) * 180 / pi\n\n   # Fungsi perhitungan sudut elevasi matahari\n   sin_beta &lt;- 3600 * (D * s_lat_delt + 24/pi * c_lat_delt * sqrt(1 - t_lat_delt^2))\n\n   # Fungsi radiasi matahari ekstra terestrial\n   S_0 &lt;- 1370 * (1 + 0.033 * cospi(360 / 180 * doy / 365)) * sin_beta\n\n   # Konversi J/m² ke MJ/m²\n   return(S_0 / 1000000)\n}\nKemudian, tambahkan kolom baru pada data yang berisi nilai \\(S_0\\) dengan perintah berikut.\ndata &lt;- data %&gt;%\n   mutate(\n      S0 = S0(40.77945, DOY) * 0.0864 # 0.0864 adalah konversi dari MJ/m² ke W/m²\n   )\ndata\n# A tibble: 8,401 × 8\n    YEAR   DOY  PRCP  TAVG  TMAX  TMIN  SRAD    S0\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  1998     1   0    -5    -1.1  -8.9 107.   1.15\n 2  1998     2   0     4.7  10    -0.6  82.8  1.16\n 3  1998     3   0    12    15.6   8.3  74.7  1.16\n 4  1998     4   0    11.7  17.2   6.1  78.8  1.17\n 5  1998     5   0     5.9   6.7   5    75.6  1.18\n 6  1998     6   1    10.3  15     5.6  34.3  1.18\n 7  1998     7  28.7   9.5  13.9   5    26.8  1.19\n 8  1998     8   0.8  10.3  16.1   4.4  37.5  1.20\n 9  1998     9   0    12    15     8.9  46.8  1.20\n10  1998    10   0     7.8  10     5.6  97.6  1.21\n# … with 8,391 more rows\n# ℹ Use `print(n = ...)` to see more rows\nUntuk membuat model, lakukan pembagian data menjadi data_test dan data_train dengan perintah berikut.\ndata_train &lt;- data %&gt;% filter(YEAR &lt;= 2018)\ndata_test &lt;- data %&gt;% filter(YEAR &gt;= 2019)\nHitunglah S0 * (Tmax - Tmin)^0.5 dan PRCP^2 dengan menambahkan dua kolom baru pada data_train dan data_test dengan perintah berikut.\ndata_train &lt;- data_train %&gt;%\n   mutate(\n      TMAX_TMIN = S0 * (TMAX - TMIN)^0.5,\n      PRCP_sq = PRCP^2\n   )\n\ndata_test &lt;- data_test %&gt;%\n   mutate(\n      TMAX_TMIN = S0 * (TMAX - TMIN)^0.5,\n      PRCP_sq = PRCP^2\n   )\nBuat model regresi linier berganda\nmodel &lt;- lm(SRAD ~ TMAX_TMIN + TMAX + PRCP + PRCP_sq, data = data_train)\nsummary(model)\nCall:\nlm(formula = SRAD ~ TMAX_TMIN + TMAX + PRCP + PRCP_sq, data = data_train)\n\nResiduals:\n    Min      1Q  Median      3Q     Max\n-303.18  -30.23    5.38   33.75  172.69\n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept) 17.315218   1.349717  12.829   &lt;2e-16 ***\nTMAX_TMIN   24.430366   0.284492  85.874   &lt;2e-16 ***\nTMAX         0.144476   0.084287   1.714   0.0866 .\nPRCP        -4.237145   0.098195 -43.150   &lt;2e-16 ***\nPRCP_sq      0.028795   0.001301  22.129   &lt;2e-16 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\nResidual standard error: 47.51 on 7665 degrees of freedom\nMultiple R-squared:  0.7396,    Adjusted R-squared:  0.7395\nF-statistic:  5443 on 4 and 7665 DF,  p-value: &lt; 2.2e-16\nKemudian, lakukan prediksi pada data_test dan evaluasi hasil estimasi model menggunakan metrik \\(R^2\\) dan korelasi Pearson dengan perintah berikut .\ndata_test &lt;- data_test %&gt;%\n   mutate(SRAD_pred = predict(model, data_test))\n\n# korelasi Pearson (r)\nr &lt;- cor(data_test$SRAD, data_test$SRAD_pred)\n\n# koefisien determinasi (R²)\nR2 &lt;- r^2\n\nprint(r); print(R2)\n[1] 0.8474758\n[1] 0.7182153\nSama seperti Ball, model Hunt juga dapat dipastikan estimasi radiasi matahari bernilai negatif. Untuk mengubahnya menjadi 0, lakukan hal yang sama seperti pada model Ball pada langkah ke-7 dan buat grafiknya (?fig-sunmodelhunt)\ndata_test &lt;- data_test %&gt;%\n   mutate(SRAD_pred = ifelse(SRAD_pred &lt; 0, 0, SRAD_pred))\n\nggplot(data_test, aes(x = SRAD_pred, y = SRAD)) +\n   geom_point() +\n   geom_abline(intercept = 0, slope = 1, color = \"blue\") +\n   scale_x_continuous(limits = c(0, 400), expand = c(0, 0)) +\n   scale_y_continuous(limits = c(0, 400), expand = c(0, 0)) +\n   labs(y = \"Observasi (W/m²)\", x = \"Model (W/m²)\") \n\n\n\n\n\n3.4.2 Python\nPackage yang digunakan adalah pandas, sklearn, dan matplotlib. Impor kedua package tersebut dengan perintah berikut.\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn import metrics\nSebelum mengimpor data dalam bentuk excel, Anda perlu memasang package openpyxl.\npip install openpyxl\n\nModel Ball et al. (2004)\n\nImpor data dengan perintah berikut.\npath = 'data'\ndata = pd.read_excel(f'{path}/LaguardiaAirport-NYC.xlsx', sheet_name='RawData')\nprint(data)\n      YEAR  DOY  PRCP  TAVG  TMAX  TMIN   SRAD\n0     1998    1   0.0  -5.0  -1.1  -8.9  106.8\n1     1998    2   0.0   4.7  10.0  -0.6   82.8\n2     1998    3   0.0  12.0  15.6   8.3   74.7\n3     1998    4   0.0  11.7  17.2   6.1   78.8\n4     1998    5   0.0   5.9   6.7   5.0   75.6\n...    ...  ...   ...   ...   ...   ...    ...\n8396  2020  362   0.0  -0.2   4.4  -2.7   99.4\n8397  2020  363   0.0   6.1  11.1   2.2   61.3\n8398  2020  364   0.0   5.6   7.2   0.0   97.1\n8399  2020  365   0.0   1.8   7.2  -1.0   56.5\n8400  2020  366  13.5   7.7  10.0   3.3   24.0\n\n[8401 rows x 7 columns]\nPilih periode tahun untuk pembuatan dan validasi model dengan perintah berikut.\n# Pembuatan model\ndata_train = data[data['YEAR'] &lt; 2019]\n# Validasi model\ndata_test = data[data['YEAR'] &gt;= 2019]\nLakukan perhitungan prediktor ke-5 sampai ke-12 sesuai dengan Tabel 3.1\ndata_train.loc[:, 'PRCP_sq']   = data_train.loc[:, 'PRCP'] ** 2\ndata_train.loc[:, 'TMAX_sq']   = data_train.loc[:, 'TMAX'] ** 2\ndata_train.loc[:, 'TMIN_sq']   = data_train.loc[:, 'TMIN'] ** 2\ndata_train.loc[:, 'DOY_sq']    = data_train.loc[:, 'DOY']  ** 2\ndata_train.loc[:, 'PRCP_TMAX'] = data_train.loc[:, 'PRCP'] * data_train.loc[:, 'TMAX']\ndata_train.loc[:, 'PRCP_TMIN'] = data_train.loc[:, 'PRCP'] * data_train.loc[:, 'TMIN']\ndata_train.loc[:, 'TMAX_TMIN'] = data_train.loc[:, 'TMAX'] * data_train.loc[:, 'TMIN']\ndata_train.loc[:, 'TMAX_DOY']  = data_train.loc[:, 'TMAX'] * data_train.loc[:, 'DOY']\nLakukan pembuatan model regresi linier berganda pada data data_train sesuai dengan model Ball (Tabel 3.1).\n# Model regresi linier\nmodel = LinearRegression()\n\nmodel.fit(\n   # Prediktor\n   data_train.loc[:, ['PRCP', 'TAVG', 'TMAX', 'TMIN', \n                      'PRCP_sq', 'TMAX_sq', 'TMIN_sq', \n                      'DOY_sq', 'PRCP_TMAX', 'PRCP_TMIN', \n                      'TMAX_TMIN', 'TMAX_DOY']],\n   # Prediktan\n   data_train.loc[:, 'SRAD']\n)\nOleh karena respon dari package sklearn tidak bisa menghasilkan summary seperti pada R, Anda perlu membuat fungsi tersendiri. Pada fungsi metrics, telah tersedia beberapa metrik yang dapat digunakan untuk mengevaluasi model.\ndef summary(model, x, y):\n   # Estimasi\n   y_pred = model.predict(x)\n\n   # Jika terdapat nilai negatif, maka nilai tersebut akan diubah menjadi 0\n   y_pred[y_pred &lt; 0] = 0\n\n   # Metrik\n   r2   = metrics.r2_score(y, y_pred)\n   rmse = metrics.mean_squared_error(y, y_pred, squared=False)\n   mae  = metrics.mean_absolute_error(y, y_pred)\n\n   print(f'R²   = {round(r2, 2)}')\n   print(f'RMSE = {round(rmse, 2)}')\n   print(f'MAE  = {round(mae, 2)}')\n\nsummary(model, \n   data_train.loc[:, ['PRCP', 'TAVG', 'TMAX', 'TMIN', \n                      'PRCP_sq', 'TMAX_sq', 'TMIN_sq', \n                      'DOY_sq', 'PRCP_TMAX', 'PRCP_TMIN', \n                      'TMAX_TMIN', 'TMAX_DOY']],\n   data_train.loc[:, 'SRAD']\n)\nR²   = 0.74\nRMSE = 47.25\nMAE  = 37.6\nUntuk memvalidasi model, Anda perlu menghitung prediktor ke-5 sampai ke-12 pada data data_test sesuai dengan Tabel 3.1. Kemudian, gunakan model.predict() untuk menghitung prediksi pada data data_test.\ndata_test.loc[:, 'PRCP_sq']   = data_test.loc[:, 'PRCP'] ** 2\ndata_test.loc[:, 'TMAX_sq']   = data_test.loc[:, 'TMAX'] ** 2\ndata_test.loc[:, 'TMIN_sq']   = data_test.loc[:, 'TMIN'] ** 2\ndata_test.loc[:, 'DOY_sq']    = data_test.loc[:, 'DOY']  ** 2\ndata_test.loc[:, 'PRCP_TMAX'] = data_test.loc[:, 'PRCP'] * data_test.loc[:, 'TMAX']\ndata_test.loc[:, 'PRCP_TMIN'] = data_test.loc[:, 'PRCP'] * data_test.loc[:, 'TMIN']\ndata_test.loc[:, 'TMAX_TMIN'] = data_test.loc[:, 'TMAX'] * data_test.loc[:, 'TMIN']\ndata_test.loc[:, 'TMAX_DOY']  = data_test.loc[:, 'TMAX'] * data_test.loc[:, 'DOY']\n\nsummary(model, \n   data_test.loc[:, ['PRCP', 'TAVG', 'TMAX', 'TMIN', \n                     'PRCP_sq', 'TMAX_sq', 'TMIN_sq', \n                     'DOY_sq', 'PRCP_TMAX', 'PRCP_TMIN', \n                     'TMAX_TMIN', 'TMAX_DOY']],\n   data_test.loc[:, 'SRAD']\n)\nR²   = 0.72\nRMSE = 51.69\nMAE  = 40.72\nUntuk membuat grafik dari data_test maupun data_train, Anda dapat menggunakan matplotlib (?fig-sunmodelballpy)\ny_pred = model.predict(data_train.loc[:, ['PRCP', 'TMAX', 'TMIN', 'DOY', \n                                          'PRCP_sq', 'TMAX_sq', 'TMIN_sq', \n                                          'DOY_sq', 'PRCP_TMAX', 'PRCP_TMIN', \n                                          'TMAX_TMIN', 'TMAX_DOY']])\n\n# Grafik data train\nplt.figure(figsize=(10, 10))\nplt.scatter(data_train.loc[:, 'SRAD'], y_pred)\n\nplt.xlim(0, 380)\nplt.ylim(0, 380)\n\n# Menambahkan label pada sumbu x dan y\nplt.xlabel('Model (W/m²)')\nplt.ylabel('Observasi (W/m²)')\n\nplt.show()\n\n\n\n\nModel Hunt et al. (1998)\n\nImpor data Excel. Caranya sama seperti pada subbab sebelumnya.\nSebelum Anda melakukan pembuatan model regresi linier berganda, Anda harus melakukan perhitungan \\(S_0\\) terlebih dahulu. Kami menyediakan fungsi untuk menghitung nilai \\(S_0\\) seperti pada Section 3.3. Anda hanya memasukkan nilai latitude serta day of year pada fungsi ini. Perlu modul tambahan numpy untuk menghitung nilai trigonometri.\nfrom numpy import sin, cos, pi, arcsin, sqrt\n\ndef S0(lat, doy):\n   # Fungsi untuk menghitung sin(delta)\n   sin_delta = -sin(pi * 23.45 / 180) * cos(pi * (360 * (doy + 10) / 365) / 180)\n   asin_delt = arcsin(sin_delta) * 180 / pi\n\n   # sin(lat) * sin(delta)\n   s_lat_delt = sin(pi * lat / 180) * sin(pi * asin_delt / 180)\n\n   # cos(lat) * cos(delta)\n   c_lat_delt = cos(pi * lat / 180) * cos(pi * asin_delt / 180)\n\n   # (sin(lat) * sin(delta)) / (cos(lat) * cos(delta))\n   t_lat_delt = s_lat_delt / c_lat_delt\n\n   # Fungi perhitungan panjang hari (D)\n   D = 12 + 24/180 * arcsin(t_lat_delt) * 180 / pi\n\n   # Fungsi perhitungan sudut elevasi matahari\n   sin_beta = 3600 * (D * s_lat_delt + 24/pi * c_lat_delt * sqrt(1 - t_lat_delt**2))\n\n   # Fungsi perhitungan radiasi matahari\n   S_0 = 1370 * (1 + 0.033 * cos(pi * 360 / 180 * doy / 365)) * sin_beta\n\n   # Konversi J/m² ke MJ/m²\n   return S_0 / 1000000\nKemudian, tambahkan kolom baru pada data yang berisi nilai \\(S_0\\) dengan perintah berikut.\ndata.loc[:, 'S0'] = S0(40.77945, data.loc[:, 'DOY'])\nUntuk membuat model, lakukan pembagian data menjadi data_test dan data_train dengan perintah berikut.\n# Pembuatan model\ndata_train = data[data['YEAR'] &lt; 2019]\n# Validasi model\ndata_test = data[data['YEAR'] &gt;= 2019]\nHitunglah S0 * (Tmax - Tmin)^0.5 dan PRCP^2 dengan menambahkan dua kolom baru pada data_train dan data_test dengan perintah berikut.\n# Data train\ndata_train.loc[:, 'S0_TMAX_TMIN'] = data_train.loc[:, 'S0'] * sqrt(data_train.loc[:, 'TMAX'] - data_train.loc[:, 'TMIN'])\ndata_train.loc[:, 'PRCP_sq'] = data_train.loc[:, 'PRCP'] ** 2\n\n# Data test\ndata_test.loc[:, 'S0_TMAX_TMIN'] = data_test.loc[:, 'S0'] * sqrt(data_test.loc[:, 'TMAX'] - data_test.loc[:, 'TMIN'])\ndata_test.loc[:, 'PRCP_sq'] = data_test.loc[:, 'PRCP'] ** 2\nBuat model regresi linier berganda\nmodel = LinearRegression()\nmodel.fit(\n   # Prediktor   \n   data_train.loc[:, ['S0_TMAX_TMIN', 'PRCP', 'PRCP_sq']], \n   # Prediktan\n   data_train.loc[:, 'SRAD']\n)\nKemudian, lakukan validasi model dengan menggunakan data_test.\nsummary(model, \n   data_test.loc[:, ['S0_TMAX_TMIN', 'PRCP', 'PRCP_sq']], \n   data_test.loc[:, 'SRAD']\n)\nR²   = 0.71\nRMSE = 52.53\nMAE  = 41.64\nTerakhir, lakukan pembuatan grafik dari data_test (?fig-sunmodelhuntpy)\ny_pred = model.predict(data_test.loc[:, ['S0_TMAX_TMIN', 'PRCP', 'PRCP_sq']])\ny_pred[y_pred &lt; 0] = 0\n\n# Visualize\nfig = plt.figure(figsize=(4, 4))\n\n# Make plot scatter with small size\nplt.scatter(y_pred, data_test.loc[:, 'SRAD'], s=1)\n\n# Make line plot 1:1\nplt.plot([0, 400], [0, 400], color='red')\n\n# expand plot area\nplt.xlim(0, 380)\nplt.ylim(0, 380)\n\n# Set axis labels\nplt.xlabel('Model (W/m²)')\nplt.ylabel('Observasi (W/m²)')\nplt.show()\n\n\n\n\n\n\nBall RA, Purcell LC, Carey SK. 2004. Evaluation of solar radiation prediction models in north america. Agronomy Journal. 96(2):391–397.\n\n\nHunt L, Kuchar L, Swanton C. 1998. Estimation of solar radiation for use in crop modelling. Agricultural and Forest Meteorology. 91(3-4):293–300.\n\n\nSpitters C, Toussaint H, Goudriaan J. 1986. Separating the diffuse and direct component of global radiation and its implications for modeling canopy photosynthesis part i. Components of incoming radiation. Agricultural and Forest Meteorology. 38(1-3):217–229."
  },
  {
    "objectID": "praktikum-3.html#pendahuluan",
    "href": "praktikum-3.html#pendahuluan",
    "title": "4  Koreksi Bias Statistik",
    "section": "4.1 Pendahuluan",
    "text": "4.1 Pendahuluan\nGlobal Climate Model (GCM) adalah alat utama dan paling komprehensif yang digunakan dalam simulasi perubahan iklim pada masa lalu maupun masa mendatang. GCM memiliki kemampuan dalam melakukan simulasi variabilitas iklim dan sifat-sifat di permukaan bumi pada skala global. Kelemahan GCM adalah ketidakmampuan menangkap kejadian-kejadian iklim pada skala regional maupun lokal karena resolusi spasial yang masih kasar. Dynamical downscalling dengan simulasi Regional Climate Model (RCM) dilakukan untuk memperhalus resolusi dari GCM. Simulasi RCM secara umum menunjukkan bias secara sistematik terhadap observasi (Li et al. 2019).\nMetode koreksi bias biasanya menggunakan fungsi transfer/koreksi yang mengubah data model menjadi data terkoreksi secara statistik. Selain Delta Method (Graham et al. 2007; Sperna Weiland et al. 2010), metode koreksi bias lain telah dikembangkan, seperti linear scalling correction, power transformation, empirical quantile mapping, dan parametric quantile mapping (Li et al. 2019). Beberapa keterbatasan dalam melakukan koreksi bias, yaitu umumnya tidak memiliki dasar fisika yang kuat, menghasilkan perubahan konsistensi secara spasial, perubahan hubungan antar variabel, melawan aturan hukum konservasi energi, tidak memperhitungkan ketidakpastian dari kumpulan data observasi dan variabilitas internal, dan galat model dan fungsi koreksi umumnya dianggap stasioner terhadap waktu (Ehret et al. 2012; Addor and Fischer 2015; Maraun 2016). Ringkasan pengklasifikasian metode koreksi bias dapat dilihat pada Tabel 4.1 (Watanabe et al. 2012).\n\n\nTabel 4.1: Klasifikasi metode koreksi bias statistik\n\n\n\n\n\n\n\n\n\n\nTipe konstan\nTipe variabel\nTipe parametrik\nTipe non-parametrik\n\n\n\n\nDefinisi\nNilai statistik pada periode masa depan tidak dimasukkan pada persamaan koreksi bias\nNilai statistik pada periode masa depan dimasukkan pada persamaan koreksi bias\nDistribusi parametrik diasumsikan masuk ke simulasi dan/atau data observasi\nDistribusi parametrik tidak digunakan dalam koreksi bias\n\n\nKarakteristik\n\nStatistik pada periode masa depan tidak mempengaruhi hasil dari koreksi bias\nPanjang data koreksi bias dapat diperoleh berapapun panjang periodenya\n\n\nStatistik pada periode masa depan mempengaruhi hasil dari koreksi bias\nMudah untuk melakukan penyesuaian perubahan secara statistik dari periode dasar ke masa depan antara data belum terkoreksi dan data terkoreksi\nPanjang data terkoreksi bias harus sama dengan data periode dasar\n\n\nKuat secara statistik\nNilai yang tidak realistis dapat dihasilkan jika distribusi tidak diperkirakan dengan baik\n\n\nDiperlukan ekstrapolasi untuk nilai-nilai yang lebih/kurang dari periode dasar\nKarena derajat bebas sama dengan jumlah parameter, ada permasalahan dalam functional robustness jika asumsinya distribusi non parametrik"
  },
  {
    "objectID": "praktikum-3.html#metode-delta",
    "href": "praktikum-3.html#metode-delta",
    "title": "4  Koreksi Bias Statistik",
    "section": "4.2 Metode Delta",
    "text": "4.2 Metode Delta\nCara paling sederhana untuk melakukan koreksi bias adalah dengan menambahkan/mengalikan data model ke data observasi pada periode dasar. Persamaan 4.1 umum digunakan pada koreksi data suhu dan Persamaan 4.2 untuk curah hujan.\n\\[\nx_{cor, i} = x_{o,i} + \\mu_{p} - \\mu_{b}\\tag{1}\n\\tag{4.1}\\]\n\\[\nx_{cor,i} = x_{o, i} . \\frac{\\mu_p}{\\mu_b} \\tag{2}\n\\tag{4.2}\\]\ndimana \\(x_{cor,i}\\) dan \\(x_{o,i}\\) \\((i = 1, 2, …)\\) secara berturut-turut dinotasikan sebagai data terkoreksi bias dan observasi dalam periode dasar tertentu, \\(\\mu\\) adalah rata-rata. Subskrip \\(b\\), \\(o\\), dan \\(p\\) secara berturut-turut adalah data dasar, observasi, dan proyeksi"
  },
  {
    "objectID": "praktikum-3.html#metode-distribusi",
    "href": "praktikum-3.html#metode-distribusi",
    "title": "4  Koreksi Bias Statistik",
    "section": "4.3 Metode Distribusi",
    "text": "4.3 Metode Distribusi\nKoreksi bias dengan metode ini berdasarkan distribusi statistik dari data model yang ditransformasikan untuk menyesuaikan distribusi data dari observasi. Distribusi normal umum diasumsikan untuk data suhu udara (Piani, Weedon, et al. 2010), sedangkan distribusi gamma untuk data curah hujan (Piani, Haerter, et al. 2010). Persamaan Probability Density Function (PDF) untuk sebaran normal (Persamaan 4.3) dan sebaran gamma (Persamaan 4.4) adalah sebagai berikut.\n\\[\nf(x, \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}} ~ e^{-0.5 (\\frac{x - \\mu}{\\sigma})^2} \\tag{3}\n\\tag{4.3}\\]\n\\[\nf(x, \\alpha, \\beta) = \\frac{exp(-\\frac{x}{\\beta}) . (\\frac{x}{\\beta})^{\\alpha-1}}{\\Gamma(\\alpha)\\beta} \\tag{4}\n\\tag{4.4}\\]\ndengan x adalah data curah hujan atau suhu udara, \\(\\alpha\\) adalah parameter skala, \\(\\beta\\) adalah parameter bentuk, \\(\\sigma\\) adalah standar deviasi, dan \\(\\mu\\) adalah rata-rata. Proses koreksi bias dihitung dari invers Cumulative Density Function (CDF). Pada Persamaan 4.4, nilai \\(\\alpha\\) dan \\(\\beta\\) dapat diestimasi dengan metode Greenwood dan Durand (Greenwood and Durand 1960). Persamaannya sebagai berikut.\n\\[\n\\alpha =\n  \\begin{cases}\n    \\frac{0.5000876+0.1648852y−0.0544276y^2}{y} &,~ \\text{jika} ~ 0 \\leq y \\leq 0.5772 \\\\\n    \\frac{8.898919+9.05995y+0.9775373y^2}{17.79728y+11.968477y^2+y^3} &, ~ \\text{jika} ~ 0.5772 &lt; y \\leq 17 \\\\\n    \\frac{1}{y} &, ~ \\text{jika} ~ y &gt; 17\n  \\end{cases} \\tag{5}\n\\tag{4.5}\\]\n\\[\ny = ln(\\bar{x}) - \\frac{1}{n} \\sum_{i = 1} ^ n ln(x_i) \\tag{6}\n\\tag{4.6}\\]\n\\[\n\\beta = \\frac{\\bar{x}}{\\alpha} \\tag{7}\n\\tag{4.7}\\]\nPersamaan Persamaan 4.5, Persamaan 4.6, Persamaan 4.7 menjadi masalah ketika menerapkannya pada data curah hujan yang bernilai 0.\n\n\n\n\nAddor N, Fischer EM. 2015. The influence of natural variability and interpolation errors on bias characterization in RCM simulations. Journal of Geophysical Research: Atmospheres. 120(19):10–180.\n\n\nEhret U, Zehe E, Wulfmeyer V, Warrach-Sagi K, Liebert J. 2012. HESS opinions\" should we apply bias correction to global and regional climate model data?\". Hydrology & Earth System Sciences Discussions. 9(4).\n\n\nGraham LP, Andréasson J, Carlsson B. 2007. Assessing climate change impacts on hydrology from an ensemble of regional climate models, model scales and linking methods–a case study on the lule river basin. Climatic Change. 81(1):293–307.\n\n\nGreenwood JA, Durand D. 1960. Aids for fitting the gamma distribution by maximum likelihood. Technometrics. 2(1):55–65.\n\n\nLi D, Feng J, Xu Z, Yin B, Shi H, Qi J. 2019. Statistical bias correction for simulated wind speeds over CORDEX-east asia. Earth and Space Science. 6(2):200–211.\n\n\nMaraun D. 2016. Bias correcting climate change simulations-a critical review. Current Climate Change Reports. 2(4):211–220.\n\n\nPiani C, Haerter J, Coppola E. 2010. Statistical bias correction for daily precipitation in regional climate models over europe. Theoretical and Applied Climatology. 99(1-2):187–192.\n\n\nPiani C, Weedon G, Best M, Gomes S, Viterbo P, Hagemann S, Haerter J. 2010. Statistical bias correction of global simulated daily precipitation and temperature for the application of hydrological models. Journal of Hydrology. 395(3-4):199–215.\n\n\nSperna Weiland F, Van Beek L, Kwadijk J, Bierkens M. 2010. The ability of a GCM-forced hydrological model to reproduce global discharge variability. Hydrology and Earth System Sciences. 14:1595–1621.\n\n\nWatanabe S, Kanae S, Seto S, Yeh PJ-F, Hirabayashi Y, Oki T. 2012. Intercomparison of bias-correction methods for monthly temperature and precipitation simulated by multiple climate models. Journal of Geophysical Research: Atmospheres. 117(D23)."
  }
]